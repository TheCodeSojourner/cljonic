#ifndef CLJONIC_CORE_REPLACE_HPP
#define CLJONIC_CORE_REPLACE_HPP

#include <concepts>
#include "cljonic-array.hpp"
#include "cljonic-concepts.hpp"

namespace cljonic
{

namespace core
{

/** \anchor Core_Replace
* The \b Replace function returns a \b cljonic \b Array with the same \b MaximumCount as its second parameter, which
* must be a \b cljonic \b collection with a value type convertible to an integral, and the same value type as its first
* parameter, which must be a \b cljonic \b collection with a value type convertible from the type of the second
* parameter. The values returned in the result are generated by iterating over the values of the second parameter, and
* concatenating one of the following values onto the result: (1) if the second parameter is a valid index into the first
* parameter, the first parameter value at that index, or (2) the second parameter value.
~~~~~{.cpp}
#include "cljonic.hpp"

using namespace cljonic;
using namespace cljonic::core;

int main()
{
    constexpr auto a{Array{1, 2, 3, 4}};
    constexpr auto ri0{Replace(a, Array{1, 2, 3, 4})};           // 2, 3, 4, 4
    constexpr auto ri1{Replace(a, Array{1, 2, 3, 14})};          // 2, 3, 4, 14
    constexpr auto ri2{Replace(a, Array{-2, 2, 3, 14})};         // -2, 3, 4, 14
    constexpr auto ri3{Replace(a, Array{11, 12, 13, 14})};       // 11, 12, 13, 14
    constexpr auto ri4{Replace(a, Array{3})};                    // 4
    constexpr auto ri5{Replace(a, Range<0>{})};                  // empty Array
    constexpr auto ri6{Replace(a, Range<7>{})};                  // 1, 2, 3, 4, 4, 5, 6
    constexpr auto ri7{Replace(a, Repeat<4, int>{3})};           // 4, 4, 4, 4
    constexpr auto ri8{Replace(a, Repeat<4, int>{33})};          // 33, 33, 33, 33
    constexpr auto ri9{Replace(a, Set{1, 2, 3, 4})};             // 2, 3, 4, 4
    constexpr auto ri10{Replace(a, String{'1', '2', '3', '4'})}; // 49, 50, 51, 52

    constexpr auto f{Array{1.1, 2.2, 3.3, 4.4}};
    constexpr auto rf0{Replace(f, Array{1, 2, 3, 4})};           // 2.2, 3.3, 4.4, 4.0
    constexpr auto rf1{Replace(f, Array{1, 2, 3, 14})};          // 2.2, 3.3, 4.4, 14.0
    constexpr auto rf2{Replace(f, Array{-2, 2, 3, 14})};         // -2.0, 3.3, 4.4, 14.0
    constexpr auto rf3{Replace(f, Array{11, 12, 13, 14})};       // 11.0, 12.0, 13.0, 14.0
    constexpr auto rf4{Replace(f, Array{3})};                    // 4.4
    constexpr auto rf5{Replace(f, Range<0>{})};                  // empty Array
    constexpr auto rf6{Replace(f, Range<7>{})};                  // 1.1, 2.2, 3.3, 4.4, 4.0, 5.0, 6.0
    constexpr auto rf7{Replace(f, Repeat<4, int>{3})};           // 4.4, 4.4, 4.4, 4.4
    constexpr auto rf8{Replace(f, Repeat<4, int>{33})};          // 33.0, 33.0, 33.0, 33.0
    constexpr auto rf9{Replace(f, Set{1, 2, 3, 4})};             // 2.2, 3.3, 4.4, 4.0
    constexpr auto rf10{Replace(f, String{'1', '2', '3', '4'})}; // 49.0, 50.0, 51.0, 52.0

    // Compiler Error: Replace's first parameter must be a cljonic collection
    // constexpr auto m{Replace("Hello", Array{1, 2, 3, 4})};

    // Compiler Error: Replace's second parameter must be a cljonic collection
    // constexpr auto m{Replace(Array{1, 2, 3, 4}, "Hello")};

    // Compiler Error: Replace's second parameter value type must be convertible to an integral
    // constexpr auto m{Replace(Array{1, 2, 3, 4}, Array{"Hello"})};

    // Compiler Error: Replace's second parameter value type must be convertible to the first parameter value type
    // constexpr auto m{Replace(Array{"Hello"}, Array{1, 2, 3, 4})};

return 0;
}
~~~~~
*/
template <typename C1, typename C2>
constexpr auto Replace(const C1& c1, const C2& c2) noexcept
{
    // #lizard forgives -- The length and complexity of this function is acceptable.

    static_assert(IsCljonicCollection<C1>, "Replace's first parameter must be a cljonic collection");

    static_assert(IsCljonicCollection<C2>, "Replace's second parameter must be a cljonic collection");

    static_assert(IsConvertibleToIntegral<C2::value_type>,
                  "Replace's second parameter value type must be convertible to an integral");

    static_assert(std::convertible_to<C2::value_type, C1::value_type>,
                  "Replace's second parameter value type must be convertible to the first parameter value type");

    using ResultType = decltype(f(std::declval<typename C::value_type>(), std::declval<typename Cs::value_type>()...));

    auto result{Array<typename C1::value_type, c2.MaximumCount()>{}};
    for (SizeType i{0}; i < c2.Count(); ++i)
        MConj(result, ((c2[i] >= 0) and (c2[i] < c1.Count())) ? c1[c2[i]] : c2[i]);
    return result;
}

} // namespace core

} // namespace cljonic

#endif // CLJONIC_CORE_REPLACE_HPP
