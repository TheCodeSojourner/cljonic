#ifndef CLJONIC_H_
#define CLJONIC_H_

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT EDIT THIS FILE.  IT IS AUTOMATICALLY GENERATED BY INVOKING 'make cljonic' WITHIN THE cljonic DIRECTORY.
//
// TO UPDATE THIS FILE, MAKE CHANGES TO THE FILES IN THE code/source DIRECTORY.
//
// ONLY cljonic DEVELOPERS SHOULD MAKE CHANGES.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) Paul Whittington All rights reserved. The use and distribution terms for this software are covered by
// the Apache License Version 2.0, January 2004 (http://www.apache.org/licenses/LICENSE-2.0). By using this software in
// any fashion, you are agreeing to be bound by the terms of this license. You must not remove this notice, or any
// other, from this software.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// This file was generated Mon Dec 16 08:19:02 AM MST 2024

namespace cljonic {

enum class CljonicCollectionType {
    Array,
    Set,
    String
};

}

#include <concepts>
#include <limits>

namespace cljonic {

template <typename T>
concept IsCljonicCollection = std::same_as<typename T::cljonic_collection, std::true_type>;

template <typename T>
concept IsCljonicSet = std::same_as<typename T::cljonic_collection_type,
                                    std::integral_constant<CljonicCollectionType, CljonicCollectionType::Set>>;

template <typename T, typename... Ts>
concept AllCljonicCollections = (IsCljonicCollection<T> and ... and IsCljonicCollection<Ts>);

template <typename T, typename... Ts>
concept AllCljonicSets = (IsCljonicSet<T> and ... and IsCljonicSet<Ts>);

template <typename T, typename... Ts>
constexpr bool AllEqualityComparableValueTypes =
    (std::equality_comparable_with<typename T::value_type, typename Ts::value_type> and ...);

template <typename T, typename... Ts>
concept AllSameCljonicCollectionType =
    (std::same_as<typename T::cljonic_collection_type, typename Ts::cljonic_collection_type> and ...);

template <typename T, typename... Ts>
constexpr bool AnyFloatingPointTypes = (std::floating_point<T> or ... or std::floating_point<Ts>);

template <typename T, typename... Ts>
constexpr bool AnyFloatingPointValueTypes =
    (std::floating_point<typename T::value_type> or ... or std::floating_point<typename Ts::value_type>);

template <typename T, typename... Ts>
constexpr bool AllEqualityComparableTypes = (std::equality_comparable_with<T, Ts> and ...);

template <typename T>
concept CString = std::same_as<T, const char*> or std::same_as<T, char*>;

} // namespace cljonic

#include <cstring>

namespace cljonic {

template <typename T, typename U>
auto AreEqual(const T& t, const U& u) {
if constexpr(CString<T> and CString<U>)
return (std::strcmp(t, u) == 0);
else {
static_assert((not std::floating_point<T>) and (not std::floating_point<U>),
              "Floating point types should not be equality compared");
static_assert(std::equality_comparable_with<T, U>, "Types are not equality comparable");
return (t == u);
}
}

} // namespace cljonic

#include <cstring>
#include <initializer_list>
#include <type_traits>

namespace cljonic {

template <typename T, std::size_t MaxElements>
class Array {
using MaxElementsType = decltype(MaxElements);

MaxElementsType m_elementCount;
T m_elementDefault;
T m_elements[MaxElements];

void InitializeElementDefault() noexcept {
m_elementDefault = T{};
}

public:
using cljonic_collection = std::true_type;
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Array>;
using size_type = MaxElementsType;
using value_type = T;

Array() : m_elementCount(0) {
InitializeElementDefault();
}

Array(const std::initializer_list<const T> elements) : m_elementCount(0) {
InitializeElementDefault();
for(const auto& element : elements) {
if(m_elementCount == MaxElements)
break;
m_elements[m_elementCount++] = element;
}
}

Array(const Array& other) = default;
Array(Array&& other) = default;

const T& operator[](const MaxElementsType index) const noexcept {
return (index < m_elementCount) ? m_elements[index] : m_elementDefault;
}

[[nodiscard]] MaxElementsType Count() const noexcept {
return m_elementCount;
}
};

template <typename... Args>
Array(Args...) -> Array<std::common_type_t<Args...>, sizeof...(Args)>;

} // namespace cljonic

#include <concepts>
#include <cstring>
#include <initializer_list>
#include <type_traits>

namespace cljonic {

template <typename T, std::size_t MaxElements>
class Set {
static_assert(not std::floating_point<T>,
              "Floating point types should not be compared for equality, hence Sets of floating point types are "
              "not allowed");

static_assert(std::equality_comparable<T>, "A Set type must be equality comparable");

using MaxElementsType = decltype(MaxElements);

MaxElementsType m_elementCount;
T m_elementDefault;
T m_elements[MaxElements];

void InitializeElementDefault() noexcept {
m_elementDefault = T{};
}

bool IsUniqueElement(const T& element) const noexcept {
auto result{true};
for(MaxElementsType i = 0; (result and (i < m_elementCount)); ++i)
result = not AreEqual(element, m_elements[i]);
return result;
}

public:
using cljonic_collection = std::true_type;
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Set>;
using size_type = MaxElementsType;
using value_type = T;

Set() : m_elementCount(0) {
InitializeElementDefault();
}

Set(const std::initializer_list<const T> elements) : m_elementCount(0) {
InitializeElementDefault();
for(const auto& element : elements) {
if(m_elementCount == MaxElements)
break;
if(IsUniqueElement(element))
m_elements[m_elementCount++] = element;
}
}

Set(const Set& other) = default;
Set(Set&& other) = default;

const T& operator[](const MaxElementsType index) const noexcept {
return (index < m_elementCount) ? m_elements[index] : m_elementDefault;
}

[[nodiscard]] MaxElementsType Count() const noexcept {
return m_elementCount;
}

bool Contains(const T& element) const noexcept {
return not IsUniqueElement(element);
}
};

template <typename... Args>
Set(Args...) -> Set<std::common_type_t<Args...>, sizeof...(Args)>;

} // namespace cljonic

#include <cstring>
#include <initializer_list>
#include <type_traits>

namespace cljonic {

template <std::size_t MaxElements>
class String {
using MaxElementsType = decltype(MaxElements);

MaxElementsType m_elementCount;
char m_elementDefault;
char m_elements[MaxElements + 1];

void InitializeElementDefault() noexcept {
m_elementDefault = '\0';
}

public:
using cljonic_collection = std::true_type;
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::String>;
using size_type = MaxElementsType;
using value_type = char;

String() : m_elementCount(0) {
InitializeElementDefault();
m_elements[0] = '\0';
}

String(const std::initializer_list<const char> elements) : m_elementCount(0) {
InitializeElementDefault();
for(const auto& element : elements) {
if(m_elementCount == MaxElements)
break;
m_elements[m_elementCount++] = element;
}
m_elements[m_elementCount] = '\0';
}

explicit String(const char* c_str) : m_elementCount(0) {
InitializeElementDefault();
while((m_elementCount < MaxElements) and ('\0' != c_str[m_elementCount])) {
m_elements[m_elementCount] = c_str[m_elementCount];
m_elementCount += 1;
}
m_elements[m_elementCount] = '\0';
}

String(const String& other) = default;
String(String&& other) = default;

char operator[](const MaxElementsType index) const noexcept {
return (index < m_elementCount) ? m_elements[index] : m_elementDefault;
}

[[nodiscard]] MaxElementsType Count() const noexcept {
return m_elementCount;
}
};

template <std::size_t N>
String(const char (&)[N]) -> String<N - 1>;

template <typename... Args>
String(Args...) -> String<sizeof...(Args)>;

} // namespace cljonic

namespace cljonic {

namespace core {
}

}

namespace cljonic {

namespace core {
template <typename T, typename... Ts>
auto Equal(const T& t, const Ts&... ts) {

if constexpr(AllCljonicCollections<T, Ts...>) {
static_assert(AllSameCljonicCollectionType<T, Ts...>,
              "Cljonic collection types are not all the same (e.g., Array, Set, or String)");
static_assert(not AnyFloatingPointValueTypes<T, Ts...>,
              "Cljonic floating point collection value types should not be compared for equality");
static_assert(AllEqualityComparableValueTypes<T, Ts...>,
              "Cljonic collection value types are not all equality comparable");
if constexpr(AllCljonicSets<T, Ts...>) {
constexpr auto EqualSets = [&](const auto& c1, const auto& c2) {
using CountType = decltype(c1.Count());
auto result{c1.Count() == c2.Count()};
for(CountType i = 0; (result and (i < c1.Count())); ++i)
result = c2.Contains(c1[i]);
return result;
};
return (EqualSets(t, ts) and ...);
} else {
constexpr auto EqualCollections = [&](const auto& c1, const auto& c2) {
using CountType = decltype(c1.Count());
auto result{c1.Count() == c2.Count()};
for(CountType i = 0; (result and (i < c1.Count())); ++i)
result = AreEqual(c1[i], c2[i]);
return result;
};
return (EqualCollections(t, ts) and ...);
}
} else {
static_assert(not AnyFloatingPointTypes<T, Ts...>, "Floating point types should not be compared for equality");
static_assert(AllEqualityComparableTypes<T, Ts...>, "Not all types are equality comparable");
return (AreEqual(t, ts) and ...);
}
}

}

} // namespace cljonic::core

#endif // CLJONIC_H_
