#ifndef CLJONIC_H_
#define CLJONIC_H_

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT EDIT THIS FILE.  IT IS AUTOMATICALLY GENERATED BY INVOKING 'make cljonic' WITHIN THE cljonic DIRECTORY.
//
// TO UPDATE THIS FILE, MAKE CHANGES TO THE FILES IN THE code/source DIRECTORY.
//
// ONLY cljonic DEVELOPERS SHOULD MAKE CHANGES.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) Paul Whittington All rights reserved. The use and distribution terms for this software are covered by
// the Apache License Version 2.0, January 2004 (http://www.apache.org/licenses/LICENSE-2.0). By using this software in
// any fashion, you are agreeing to be bound by the terms of this license. You must not remove this notice, or any
// other, from this software.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// This file was generated Wed Apr  9 01:19:37 PM MDT 2025

namespace cljonic {

enum class CljonicCollectionType {
    Array,
    Cycle,
    Iterator,
    Range,
    Repeat,
    Set,
    String
};

}

#include <concepts>
#include <limits>
#include <type_traits>

namespace cljonic {

namespace inner_find_common_type {

template <typename T, typename... Ts>
struct InnerFindCommonType;

template <typename T>
struct InnerFindCommonType<T> {
using type = T;
};

template <typename T, typename U, typename... Ts>
struct InnerFindCommonType<T, U, Ts...> {

using type = std::conditional_t<(std::convertible_to<U, T> && ... && std::convertible_to<Ts, T>),
                                typename InnerFindCommonType<T, Ts...>::type,
                                typename InnerFindCommonType<U, Ts...>::type>;
};

} // namespace inner_find_common_type

using namespace inner_find_common_type;

template <typename T>
concept IsArithmetic = std::integral<T> or std::floating_point<T>;

template <typename P, typename T, typename U>
concept IsBinaryPredicate = requires(P p, T a, U b) {
{ p(a, b) } -> std::convertible_to<bool>;
};

template <typename P, typename T, typename... Ts>
concept IsBinaryPredicateForAll = (IsBinaryPredicate<P, T, Ts> && ...);

template <typename F, typename T, typename... Ts>
concept IsBinaryPredicateForAllCombinations =
    (IsBinaryPredicate<F, T, Ts> && ...) && (IsBinaryPredicate<F, Ts, T> && ...);

template <typename T>
concept IsCljonicArray = std::same_as<typename T::cljonic_collection_type,
                                      std::integral_constant<CljonicCollectionType, CljonicCollectionType::Array>>;

template <typename T>
concept IsCljonicCollection = requires { typename T::cljonic_collection_type; };

template <typename T>
concept IsCljonicIterator =
    std::same_as<typename T::cljonic_collection_type,
                 std::integral_constant<CljonicCollectionType, CljonicCollectionType::Iterator>>;

template <typename T>
concept IsCljonicRange = std::same_as<typename T::cljonic_collection_type,
                                      std::integral_constant<CljonicCollectionType, CljonicCollectionType::Range>>;

template <typename T>
concept IsCljonicRepeat = std::same_as<typename T::cljonic_collection_type,
                                       std::integral_constant<CljonicCollectionType, CljonicCollectionType::Repeat>>;

template <typename T>
concept IsCljonicSet = std::same_as<typename T::cljonic_collection_type,
                                    std::integral_constant<CljonicCollectionType, CljonicCollectionType::Set>>;

template <typename T>
concept IsCljonicString = std::same_as<typename T::cljonic_collection_type,
                                       std::integral_constant<CljonicCollectionType, CljonicCollectionType::String>>;

template <typename T>
concept IsCljonicNonSet = IsCljonicCollection<T> and (not IsCljonicSet<T>);

template <typename T>
concept IsConvertibleToIntegral = std::convertible_to<T, char> or std::convertible_to<T, short> or std::convertible_to<T, int> or std::convertible_to<T, long> or std::convertible_to<T, long long>;

template <typename T>
concept IsCString = std::same_as<std::decay_t<T>, char*> or std::same_as<std::decay_t<T>, const char*>;

template <typename T>
concept IsFloatingPointOrFloatingPointValueType =
    std::floating_point<T> or (requires { typename T::value_type; } and std::floating_point<typename T::value_type>);

template <typename T>
concept IsNotCljonicCollection = not IsCljonicCollection<T>;

template <typename T>
concept IsNotCljonicSet = not IsCljonicSet<T>;

template <typename T>
concept IsReference = std::is_pointer_v<T> || std::is_reference_v<T>;

template <typename T, typename U>
concept IsReferenceAndIntegral = (IsReference<T> and std::integral<U>) or (IsReference<U> and std::integral<T>);

template <typename T>
concept IsReferenceValueType = IsReference<typename T::value_type>;

template <typename T, typename U>
concept IsReferenceAndIntegralValueType =
    (IsReference<typename T::value_type> and std::integral<typename U::value_type>) or
    (IsReference<typename U::value_type> and std::integral<typename T::value_type>);

template <typename P, typename T>
concept IsUnaryFunction = requires(P p, T t) {
{ p(t) } -> std::convertible_to<T>;
};

template <typename P, typename T>
concept IsUnaryPredicate = requires(P p, T t) {
{ p(t) } -> std::convertible_to<bool>;
};

template <typename T, typename... Ts>
concept AllCljonicNonSet = (IsCljonicNonSet<T> and ... and IsCljonicNonSet<Ts>);

template <typename T, typename... Ts>
concept AllCljonicCollections = (IsCljonicCollection<T> and ... and IsCljonicCollection<Ts>);

template <typename T, typename... Ts>
concept AllCljonicSets = (IsCljonicSet<T> and ... and IsCljonicSet<Ts>);

template <typename T, typename... Ts>
constexpr bool AllConvertibleTypes = (std::convertible_to<T, Ts> and ...);

template <typename T, typename... Ts>
constexpr bool AllConvertibleValueTypes =
    (AllConvertibleTypes<typename T::value_type, typename Ts::value_type> and ...);

template <typename T, typename... Ts>
constexpr bool AllEqualityComparableTypes = (std::equality_comparable_with<T, Ts> and ...);

template <typename T, typename... Ts>
constexpr bool AllEqualityComparableValueTypes =
    (std::equality_comparable_with<typename T::value_type, typename Ts::value_type> and ...);

template <typename T, typename... Ts>
constexpr bool AnyFloatingPointOrFloatingPointValueType =
    (IsFloatingPointOrFloatingPointValueType<T> or ... or IsFloatingPointOrFloatingPointValueType<Ts>);

template <typename T, typename... Ts>
constexpr bool AnyFloatingPointTypes = (std::floating_point<T> or ... or std::floating_point<Ts>);

template <typename T, typename... Ts>
concept AllNotCljonicCollections = (IsNotCljonicCollection<T> and ... and IsNotCljonicCollection<Ts>);

template <typename T, typename... Ts>
concept AllNotCljonicSets = (IsNotCljonicSet<T> and ... and IsNotCljonicSet<Ts>);

template <typename T, typename... Ts>
concept AllSameCljonicCollectionType =
    (std::same_as<typename T::cljonic_collection_type, typename Ts::cljonic_collection_type> and ...);

template <typename T, typename... Ts>
constexpr bool AnyCljonicSets = (IsCljonicSet<T> or ... or IsCljonicSet<Ts>);

template <typename T, typename... Ts>
constexpr bool AnyFloatingPointValueTypes =
    (std::floating_point<typename T::value_type> or ... or std::floating_point<typename Ts::value_type>);

template <typename T, typename U>
concept EqualityComparableValueTypes = std::equality_comparable_with<typename T::value_type, typename U::value_type>;

template <typename T, typename... Ts>
using FindCommonType = typename InnerFindCommonType<T, Ts...>::type;

template <typename T, typename... Ts>
using CommonValueType = typename InnerFindCommonType<typename T::value_type, typename Ts::value_type...>::type;

template <typename F, IsCljonicCollection T, IsCljonicCollection... Ts>
constexpr bool IsBinaryPredicateForAllCljonicCollections =
    (IsBinaryPredicateForAll<F, typename T::value_type, typename Ts::value_type> and ...);

} // namespace cljonic

#include <concepts>
#include <cstddef>
#include <limits>
#include <string_view>

#ifndef TYPE_CLJONIC_CHAR
#define TYPE_CLJONIC_CHAR char
#endif

#ifndef TYPE_CLJONIC_RANGE
#define TYPE_CLJONIC_RANGE int
#endif

#ifndef CONSTANT_CLJONIC_COLLECTION_MAXIMUM_ELEMENT_COUNT
#define CONSTANT_CLJONIC_COLLECTION_MAXIMUM_ELEMENT_COUNT 1000
#endif

namespace cljonic {

using CharType = TYPE_CLJONIC_CHAR;
using RangeType = TYPE_CLJONIC_RANGE;
using SizeType = std::size_t;

constexpr auto CljonicCollectionMaximumElementCount{
    static_cast<SizeType>(CONSTANT_CLJONIC_COLLECTION_MAXIMUM_ELEMENT_COUNT)};
constexpr auto CljonicInvalidIndex{std::numeric_limits<SizeType>::max()};

constexpr bool CStringsEqual(const char* str1, const char* str2) noexcept {
while(*str1 and (*str1 == *str2)) {
++str1;
++str2;
}
return *str1 == *str2;
}

template <typename T, typename U>
constexpr bool AreEqualValues(const T& t, const U& u) {

if constexpr(IsCString<T> and IsCString<U>) {
return CStringsEqual(t, u);
} else if constexpr(IsCString<T> and IsCljonicString<U>) {
return CStringsEqual(t, u.c_str());
} else if constexpr(IsCljonicString<T> and IsCString<U>) {
return CStringsEqual(t.c_str(), u);
} else if constexpr(IsCljonicString<T> and IsCljonicString<U>) {
return CStringsEqual(t.c_str(), u.c_str());
} else if constexpr((IsCljonicCollection<T> and IsNotCljonicCollection<U>) or
                    (IsNotCljonicCollection<T> and IsCljonicCollection<U>)) {
return false;
} else if constexpr(IsCljonicCollection<T> and IsCljonicCollection<U>) {
if constexpr((not IsCljonicSet<T>) and (not IsCljonicSet<U>)) {
static constexpr auto AreNonSetCollectionsEqual =
    []<typename FirstCollection, typename SecondCollection>(const SizeType firstCount,
                                                            const SizeType secondCount,
                                                            const FirstCollection& firstCollection,
                                                            const SecondCollection& secondCollection) {
    if constexpr((not EqualityComparableValueTypes<FirstCollection, SecondCollection>) or std::floating_point<typename FirstCollection::value_type> or std::floating_point<typename SecondCollection::value_type> or IsReferenceAndIntegralValueType<FirstCollection, SecondCollection>) {
    return false;
    } else if constexpr(IsCljonicRepeat<FirstCollection> and IsCljonicRepeat<SecondCollection>) {
    return (firstCount != secondCount) ? false
                                       : (*firstCollection.begin() == *secondCollection.begin());
    } else {
    if(firstCount != secondCount)
    return false;
    for(
        auto itFirst{firstCollection.begin()},
        endFirst{firstCollection.end()},
        itSecond{secondCollection.begin()},
        endSecond{secondCollection.end()};

        ((itFirst != endFirst) and (itSecond != endSecond));

        ++itFirst,
        ++itSecond) {
    if(not AreEqualValues(*itFirst, *itSecond))
    return false;
    }
    return true;
    }
    };

if constexpr(IsCljonicArray<T> and IsCljonicArray<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicArray<T> and IsCljonicIterator<U>) {
return AreNonSetCollectionsEqual(t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicArray<T> and IsCljonicRange<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicArray<T> and IsCljonicRepeat<U>) {
return AreNonSetCollectionsEqual(t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicArray<T> and IsCljonicString<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicIterator<T> and IsCljonicArray<U>) {
return AreNonSetCollectionsEqual(u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicIterator<T> and IsCljonicIterator<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicIterator<T> and IsCljonicRange<U>) {
return AreNonSetCollectionsEqual(u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicIterator<T> and IsCljonicRepeat<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicIterator<T> and IsCljonicString<U>) {
return AreNonSetCollectionsEqual(u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRange<T> and IsCljonicArray<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRange<T> and IsCljonicIterator<U>) {
return AreNonSetCollectionsEqual(t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicRange<T> and IsCljonicRange<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRange<T> and IsCljonicRepeat<U>) {
return AreNonSetCollectionsEqual(t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicRange<T> and IsCljonicString<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRepeat<T> and IsCljonicArray<U>) {
return AreNonSetCollectionsEqual(u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRepeat<T> and IsCljonicIterator<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRepeat<T> and IsCljonicRange<U>) {
return AreNonSetCollectionsEqual(u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRepeat<T> and IsCljonicRepeat<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRepeat<T> and IsCljonicString<U>) {
return AreEqualValues(*t.begin(), u.c_str());
} else if constexpr(IsCljonicString<T> and IsCljonicArray<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicString<T> and IsCljonicIterator<U>) {
return AreNonSetCollectionsEqual(t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicString<T> and IsCljonicRange<U>) {
return AreNonSetCollectionsEqual(t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicString<T> and IsCljonicRepeat<U>) {
return AreEqualValues(t.c_str(), *u.begin());
} else {
return false;
}
} else if constexpr(IsCljonicSet<T> and IsCljonicSet<U>) {
if constexpr((not EqualityComparableValueTypes<T, U>) or std::floating_point<typename T::value_type> or std::floating_point<typename U::value_type> or IsReferenceAndIntegralValueType<T, U>) {
return false;
} else {
if(t.Count() != u.Count())
return false;
for(const auto& vt : t)
if(not u.Contains(vt))
return false;
return true;
}
} else {
return false;
}
} else if constexpr((not std::equality_comparable_with<T, U>) or std::floating_point<T> or std::floating_point<U> or IsReferenceAndIntegral<T, U>) {
return false;
} else {
return t == u;
}
}

template <typename F, typename T, typename U>
constexpr bool AreEqualValuesBy(F&& f, const T& t, const U& u) {

if constexpr(IsCljonicCollection<T> and IsCljonicCollection<U>) {
if constexpr(not IsBinaryPredicate<F, typename T::value_type, typename U::value_type>) {
return false;
} else if constexpr((not IsCljonicSet<T>) and (not IsCljonicSet<U>)) {
static constexpr auto AreNonSetCollectionsEqual =
    []<typename FN, typename FirstCollection, typename SecondCollection>(
        FN&& fn,
        const SizeType firstCount,
        const SizeType secondCount,
        const FirstCollection& firstCollection,
        const SecondCollection& secondCollection) {
    if constexpr(IsCljonicRepeat<FirstCollection> and IsCljonicRepeat<SecondCollection>) {
    return std::forward<FN>(fn)(*firstCollection.begin(), *secondCollection.begin());
    } else {
    if(firstCount != secondCount)
    return false;
    for(
        auto itFirst{firstCollection.begin()},
        endFirst{firstCollection.end()},
        itSecond{secondCollection.begin()},
        endSecond{secondCollection.end()};

        ((itFirst != endFirst) and (itSecond != endSecond));

        ++itFirst,
        ++itSecond) {
    if(not std::forward<FN>(fn)(*itFirst, *itSecond))
    return false;
    }
    return true;
    }
    };

if constexpr(IsCljonicArray<T> and IsCljonicArray<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicArray<T> and IsCljonicIterator<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicArray<T> and IsCljonicRange<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicArray<T> and IsCljonicRepeat<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicArray<T> and IsCljonicString<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicIterator<T> and IsCljonicArray<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicIterator<T> and IsCljonicIterator<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicIterator<T> and IsCljonicRange<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicIterator<T> and IsCljonicRepeat<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicIterator<T> and IsCljonicString<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRange<T> and IsCljonicArray<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRange<T> and IsCljonicIterator<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicRange<T> and IsCljonicRange<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRange<T> and IsCljonicRepeat<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicRange<T> and IsCljonicString<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRepeat<T> and IsCljonicArray<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRepeat<T> and IsCljonicIterator<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRepeat<T> and IsCljonicRange<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRepeat<T> and IsCljonicRepeat<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicRepeat<T> and IsCljonicString<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), u.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicString<T> and IsCljonicArray<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicString<T> and IsCljonicIterator<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicString<T> and IsCljonicRange<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else if constexpr(IsCljonicString<T> and IsCljonicRepeat<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), t.Count(), t, u);
} else if constexpr(IsCljonicString<T> and IsCljonicString<U>) {
return AreNonSetCollectionsEqual(std::forward<F>(f), t.Count(), u.Count(), t, u);
} else {
return false;
}
} else if constexpr(IsCljonicSet<T> and IsCljonicSet<U>) {
if(t.Count() != u.Count())
return false;
for(const auto& vt : t)
if(not u.ContainsBy(std::forward<F>(f), vt))
return false;
return true;
} else if constexpr(IsBinaryPredicate<F, T, U>) {
return std::forward<F>(f)(t, u);
} else {
return false;
}
} else if constexpr(IsBinaryPredicate<F, T, U>) {
return std::forward<F>(f)(t, u);
} else {
return false;
}
}

template <typename CollectionIterator, SizeType MaxElements>
constexpr bool AreUniqueValues(const CollectionIterator& begin, const CollectionIterator& end) {

std::array<typename CollectionIterator::value_type, MaxElements> collectionElements{};
SizeType count{0};
for(auto it{begin}; it != end; ++it) {
for(SizeType i{0}; i < count; ++i)
if(AreEqualValues(collectionElements[i], *it))
return false;
if(count < MaxElements)
collectionElements[count++] = *it;
else
return false;
}
return true;
}

template <typename F, typename CollectionIterator, SizeType MaxElements>
constexpr bool AreUniqueValuesBy(F&& f, const CollectionIterator& begin, const CollectionIterator& end) {

std::array<typename CollectionIterator::value_type, MaxElements> collectionElements{};
SizeType count{0};
for(auto it{begin}; it != end; ++it) {
for(SizeType i{0}; i < count; ++i)
if(AreEqualValuesBy(std::forward<F>(f), collectionElements[i], *it))
return false;
if(count < MaxElements)
collectionElements[count++] = *it;
else
return false;
}
return true;
}

template <typename T, typename U>
constexpr bool FirstLessThanSecond(const T& t, const U& u) noexcept {

if constexpr(IsCString<T> and IsCString<U>) {
while(*t and (*t == *u)) {
++t;
++u;
}
return *t < *u;
} else {
return t < u;
}
}

template <typename T, typename... Ts>
constexpr auto MinArgument(T a, Ts... args) noexcept {
if constexpr(sizeof...(args) == 0) {
return a;
} else {
return (a < MinArgument(args...)) ? a : MinArgument(args...);
}
}

template <typename C, typename... Cs>
constexpr auto MinimumOfCljonicCollectionMaximumCounts() {
if constexpr(sizeof...(Cs) == 0) {
return C::MaximumCount();
} else {
return (MinArgument(C::MaximumCount(), Cs::MaximumCount()), ...);
}
}

template <typename C, typename... Cs>
constexpr auto SumOfCljonicCollectionMaximumCounts() {
if constexpr(sizeof...(Cs) == 0) {
return C::MaximumCount();
} else {
return (C::MaximumCount() + ... + Cs::MaximumCount());
}
}

constexpr SizeType MaximumElements(const SizeType count) noexcept {
return MinArgument(count, CljonicCollectionMaximumElementCount);
}

} // namespace cljonic

namespace cljonic {

template <typename T, SizeType MaxElements>
class Array;

template <typename T, typename F>
class Iterator;

template <RangeType... StartEndStep>
class Range;

template <SizeType MaxElements, typename T>
class Repeat;

template <typename T, SizeType MaximumElements>
class Set;

template <SizeType MaximumElements>
class String;

namespace core {

template <typename F1, typename F2>
constexpr auto Compose(F1&& f1, F2&& f2) noexcept;

constexpr auto Concat() noexcept;

template <typename C, typename... Cs>
constexpr auto Concat(const C& c, const Cs&... cs) noexcept;

template <typename C, typename... Es>
constexpr auto Conj(const C& c, const Es&... es) noexcept;

template <typename C>
constexpr auto Count(const C& c) noexcept;

template <typename C>
constexpr auto Cycle(const C& c) noexcept;

template <typename C>
constexpr auto Dedupe(const C& c) noexcept;

template <typename F, typename C>
constexpr auto DedupeBy(F&& f, const C& c) noexcept;

template <typename C>
constexpr auto DefaultElement(const C& c) noexcept;

template <typename C>
constexpr auto Drop(const SizeType count, const C& c) noexcept;

template <typename C>
constexpr auto DropLast(const SizeType count, const C& c) noexcept;

template <typename F, typename C>
constexpr auto DropWhile(F&& f, const C& c) noexcept;

template <typename T, typename... Ts>
constexpr auto Equal(const T& t, const Ts&... ts) noexcept;

template <typename F, typename T, typename... Ts>
constexpr auto EqualBy(F&& f, const T& t, const Ts&... ts) noexcept;

template <typename F, typename C>
constexpr auto Every(F&& f, const C& c) noexcept;

template <typename F, typename C>
constexpr auto Filter(F&& f, const C& c) noexcept;

template <typename C>
constexpr auto First(const C& coll) noexcept;

template <typename T, typename... Ts>
constexpr auto Identical(const T& t, const Ts&... ts) noexcept;

template <typename T>
constexpr void* Identity(const T& t) noexcept;

template <typename T>
constexpr auto Inc(const T t) noexcept;

template <typename C, typename T>
constexpr auto IndexOf(const C& c, const T& t) noexcept;

template <typename F, typename C, typename T>
constexpr auto IndexOfBy(F&& f, const C& c, const T& t) noexcept;

constexpr auto Interleave() noexcept;

template <typename C, typename... Cs>
constexpr auto Interleave(const C& c, const Cs&... cs) noexcept;

template <typename T, typename C>
constexpr auto Interpose(const T& t, const C& c) noexcept;

template <typename T, typename... Ts>
constexpr auto IsDistinct(const T& t, const Ts&... ts) noexcept;

template <typename F, typename T, typename... Ts>
constexpr auto IsDistinctBy(F&& f, const T& t, const Ts&... ts) noexcept;

template <typename C>
constexpr auto IsEmpty(const C& c) noexcept;

template <typename C>
constexpr auto IsFull(const C& c) noexcept;

template <typename F, typename T>
constexpr auto Iterate(F&& f, const T& t) noexcept;

template <typename C>
constexpr auto Last(const C& c) noexcept;

template <typename C, typename T>
constexpr auto LastIndexOf(const C& c, const T& t) noexcept;

template <typename F, typename C, typename T>
constexpr auto LastIndexOfBy(F&& f, const C& c, const T& t) noexcept;

template <typename F, typename C, typename... Cs>
constexpr auto Map(F&& f, const C& c, const Cs&... cs) noexcept;

template <typename T, typename... Ts>
constexpr auto Max(const T& t, const Ts&... ts) noexcept;

template <typename F, typename T, typename... Ts>
constexpr auto MaxBy(F&& f, const T& t, const Ts&... ts) noexcept;

template <typename T, typename... Ts>
constexpr auto Min(const T& t, const Ts&... ts) noexcept;

template <typename F, typename T, typename... Ts>
constexpr auto MinBy(F&& f, const T& t, const Ts&... ts) noexcept;

template <typename F, typename C>
constexpr auto NotAny(F&& f, const C& c) noexcept;

template <typename F, typename C>
constexpr auto NotEvery(F&& f, const C& c) noexcept;

template <typename C>
constexpr auto Nth(const C& c, const SizeType index) noexcept;

template <typename C, typename T>
constexpr auto Nth(const C& c, const SizeType index, const T& t) noexcept;

template <typename F, typename... Args>
constexpr auto Partial(F&& f, Args&&... args) noexcept;

template <typename F, typename C>
constexpr auto Reduce(F&& f, const C& c) noexcept;

template <typename F, typename C>
constexpr auto Remove(F&& f, const C& c) noexcept;

template <typename C1, typename C2>
constexpr auto Replace(const C1& c1, const C2& c2) noexcept;

template <typename C>
constexpr auto Reverse(const C& c) noexcept;

template <typename C>
constexpr auto Second(const C& c) noexcept;

template <typename C>
constexpr auto Seq(const C& c) noexcept;

template <typename C>
constexpr auto Size(const C& c) noexcept;

template <typename F, typename C>
constexpr auto Some(F&& f, const C& c) noexcept;

template <typename F, typename C>
constexpr auto Sort(F&& f, const C& c) noexcept;

template <typename F, typename C>
constexpr auto SortBy(F&& f, const C& c) noexcept;

template <typename C>
constexpr auto SplitAt(const SizeType count, const C& c) noexcept;

template <typename F, typename C>
constexpr auto SplitWith(F&& f, const C& c) noexcept;

template <typename C>
constexpr auto Subs(const C& c, const SizeType start, const SizeType end) noexcept;

template <typename C>
constexpr auto Take(const SizeType count, const C& c) noexcept;

template <typename C>
constexpr auto TakeLast(const SizeType count, const C& c) noexcept;

template <typename C>
constexpr auto TakeNth(const SizeType nth, const C& c) noexcept;

template <typename F, typename C>
constexpr auto TakeWhile(F&& f, const C& c) noexcept;

} // namespace core

} // namespace cljonic

#include <array>
#include <cstring>
#include <initializer_list>
#include <type_traits>

namespace cljonic {
template <typename T, SizeType MaxElements>
class Array {
static constexpr SizeType maximumElements{MaximumElements(MaxElements)};

static_assert(maximumElements == MaxElements,
              "Attempt to create an Array bigger than CljonicCollectionMaximumElementCount");

SizeType m_elementCount{0};
T m_elementDefault{T{}};
std::array<T, MaxElements> m_elements{};

template <typename U, SizeType N>
constexpr friend void MConj(Array<U, N>& array, const U& value) noexcept;

template <typename U, SizeType N>
constexpr friend void MSet(Array<U, N>& array, const U& value, const SizeType index) noexcept;

class ArrayIterator final {
const T* m_elementsPointer;

public:
using value_type = T;

constexpr explicit ArrayIterator(const T* elementsPointer) noexcept : m_elementsPointer{elementsPointer} {
}

[[nodiscard]] constexpr const T& operator*() const noexcept {
return *m_elementsPointer;
}

constexpr ArrayIterator& operator++() noexcept {
++m_elementsPointer;
return *this;
}

[[nodiscard]] constexpr bool operator!=(const ArrayIterator& other) const noexcept {
return m_elementsPointer != other.m_elementsPointer;
}
};

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Array>;
using size_type = SizeType;
using value_type = T;

constexpr Array() noexcept = default;

constexpr Array(const std::initializer_list<T>& init) noexcept
    : m_elementCount{std::min(init.size(), m_elements.size())}, m_elementDefault(T{}) {
std::copy(init.begin(), (init.begin() + m_elementCount), m_elements.begin());
}

constexpr Array(const Array& other) noexcept = default;
constexpr Array(Array&& other) noexcept = default;

[[nodiscard]] constexpr bool operator==(const auto& other) const noexcept {
return AreEqualValues(this, other);
}

[[nodiscard]] constexpr ArrayIterator begin() noexcept {
return ArrayIterator{m_elements.data()};
}

[[nodiscard]] constexpr ArrayIterator end() noexcept {
return ArrayIterator{m_elements.data() + m_elementCount};
}

[[nodiscard]] constexpr ArrayIterator begin() const noexcept {
return ArrayIterator{m_elements.data()};
}

[[nodiscard]] constexpr ArrayIterator end() const noexcept {
return ArrayIterator{m_elements.data() + m_elementCount};
}

[[nodiscard]] constexpr T operator()(const SizeType index) const noexcept {
return (index < m_elementCount) ? m_elements[index] : m_elementDefault;
}

[[nodiscard]] constexpr SizeType Count() const noexcept {
return m_elementCount;
}

[[nodiscard]] constexpr const T& DefaultElement() const noexcept {
return m_elementDefault;
}

[[nodiscard]] static constexpr SizeType MaximumCount() noexcept {
return maximumElements;
}
};

template <typename... Args>
Array(Args...) -> Array<std::common_type_t<Args...>, sizeof...(Args)>;

template <typename T = int>
Array() -> Array<T, 0>;

template <typename U, SizeType N>
constexpr void MConj(Array<U, N>& array, const U& value) noexcept {
if(array.m_elementCount < array.MaximumCount())
array.m_elements[array.m_elementCount++] = value;
}

template <typename U, SizeType N>
constexpr void MSet(Array<U, N>& array, const U& value, const SizeType index) noexcept {
if(index < array.m_elementCount)
array.m_elements[index] = value;
}

} // namespace cljonic

#include <concepts>
#include <utility>

namespace cljonic {
template <typename F, typename T>
class Iterator {
static constexpr T m_elementDefault{};
F m_f;
T m_initialValue;

class IteratorIterator final {
SizeType m_count;
F m_f;
T m_value;

public:
using value_type = T;

constexpr IteratorIterator(const SizeType count, F f, const T& value) noexcept
    : m_count{count}, m_f{std::move(f)}, m_value{value} {
}

[[nodiscard]] constexpr const T& operator*() const noexcept {
return m_value;
}

constexpr IteratorIterator& operator++() noexcept {
++m_count;
m_value = m_f(m_value);
return *this;
}

[[nodiscard]] constexpr bool operator!=(const IteratorIterator& other) const noexcept {
return m_count != other.m_count;
}
};

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Iterator>;
using size_type = SizeType;
using value_type = T;

template <typename Func, typename InitValue>
Iterator(Func&& f, InitValue&& initialValue) noexcept
    : m_f(std::forward<Func>(f)), m_initialValue(std::forward<InitValue>(initialValue)) {
static_assert(IsUnaryFunction<F, T>,
              "Iterator constructor's first parameter is not a unary function of its second parameter");
}

constexpr Iterator(const Iterator& other) noexcept = default;
constexpr Iterator(Iterator&& other) noexcept = default;

[[nodiscard]] constexpr bool operator==(const auto& other) const noexcept {
return AreEqualValues(this, other);
}

[[nodiscard]] constexpr IteratorIterator begin() noexcept {
return {0, m_f, m_initialValue};
}

[[nodiscard]] constexpr IteratorIterator end() noexcept {
return {Count(), m_f, m_initialValue};
}

[[nodiscard]] constexpr IteratorIterator begin() const noexcept {
return IteratorIterator{0, m_f, m_initialValue};
}

[[nodiscard]] constexpr IteratorIterator end() const noexcept {
return IteratorIterator{Count(), m_f, m_initialValue};
}

[[nodiscard]] constexpr SizeType Count() const noexcept {
return CljonicCollectionMaximumElementCount;
}

[[nodiscard]] constexpr const T& DefaultElement() const noexcept {
return m_elementDefault;
}

[[nodiscard]] static constexpr auto MaximumCount() noexcept {
return CljonicCollectionMaximumElementCount;
}
};

template <typename F, typename T>
Iterator(F, T) -> Iterator<F, T>;

} // namespace cljonic

#include <concepts>

namespace cljonic {

template <RangeType... StartEndStep>
class Range {
static_assert(sizeof...(StartEndStep) <= 3, "Number of Range parameters must be less than or equal to three");

static constexpr RangeType values[] = {StartEndStep...};

[[nodiscard]] static constexpr RangeType RangeStart() noexcept {
return (sizeof...(StartEndStep) < 2) ? 0 : values[0];
}

[[nodiscard]] static constexpr RangeType RangeStep() noexcept {
return (sizeof...(StartEndStep) < 3) ? 1 : values[2];
}

[[nodiscard]] static constexpr bool
IsEmptyRange(RangeType elementEnd, RangeType elementStart, RangeType elementStep) noexcept {
return ((elementStep == 0) and (elementStart == elementEnd)) or ((elementStep > 0) and (elementStart >= elementEnd)) or ((elementStep < 0) and (elementStart <= elementEnd));
}

static constexpr bool IsRepeatRange(RangeType elementEnd, RangeType elementStart, RangeType elementStep) noexcept {
return ((elementStep == 0) and (elementStart != elementEnd));
}

[[nodiscard]] static constexpr SizeType
RangeCount(RangeType elementEnd, RangeType elementStart, RangeType elementStep) noexcept {

return IsEmptyRange(elementEnd, elementStart, elementStep)
           ? 0
       : IsRepeatRange(elementEnd, elementStart, elementStep)
           ? CljonicCollectionMaximumElementCount
           : static_cast<SizeType>(((elementEnd - elementStart) / elementStep) +
                                   ((((elementEnd - elementStart) % elementStep) == 0) ? 0 : 1));
}

static constexpr auto MaxElements = []() constexpr {
if constexpr(sizeof...(StartEndStep) == 1) {
return RangeCount(values[0], 0, 1);
} else if constexpr(sizeof...(StartEndStep) == 2) {
return RangeCount(values[1], values[0], 1);
} else if constexpr(sizeof...(StartEndStep) == 3) {
return RangeCount(values[1], values[0], values[2]);
} else {
return RangeCount(static_cast<RangeType>(CljonicCollectionMaximumElementCount), 0, 1);
}
}();

static constexpr SizeType maximumElements{MaximumElements(MaxElements)};

static_assert(maximumElements == MaxElements,
              "Attempt to create a Range bigger than CljonicCollectionMaximumElementCount");

static constexpr SizeType m_elementCount{maximumElements};
static constexpr RangeType m_elementDefault{};
static constexpr RangeType m_elementStart{RangeStart()};
static constexpr RangeType m_elementStep{RangeStep()};

class RangeIterator final {
SizeType m_count;
RangeType m_current;
const RangeType m_step;

public:
using value_type = RangeType;

constexpr RangeIterator(const SizeType count, const RangeType current, const RangeType step) noexcept
    : m_count{count}, m_current{current}, m_step{step} {
}

[[nodiscard]] constexpr RangeIterator(const RangeIterator& other) noexcept = default;

[[nodiscard]] constexpr const RangeType& operator*() const noexcept {
return m_current;
}

constexpr RangeIterator& operator++() noexcept {
m_count += 1;
m_current += m_step;
return *this;
}

[[nodiscard]] constexpr bool operator!=(const RangeIterator& other) const noexcept {
return m_count != other.m_count;
}

constexpr RangeIterator& operator=(const RangeIterator& other) noexcept {
if(this != &other) {
m_count = other.m_count;
m_current = other.m_current;
}
return *this;
}
};

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Range>;
using size_type = SizeType;
using value_type = int;

constexpr Range() noexcept = default;
constexpr Range(const Range& other) noexcept = default;
constexpr Range(Range&& other) noexcept = default;

[[nodiscard]] constexpr bool operator==(const auto& other) const noexcept {
return AreEqualValues(this, other);
}

[[nodiscard]] constexpr RangeIterator begin() const noexcept {
return RangeIterator{0, m_elementStart, m_elementStep};
}

[[nodiscard]] constexpr RangeIterator end() const noexcept {
return RangeIterator{Count(), 0, 0};
}

[[nodiscard]] constexpr SizeType Count() const noexcept {
return m_elementCount;
}

[[nodiscard]] constexpr const RangeType& DefaultElement() const noexcept {
return m_elementDefault;
}

[[nodiscard]] static constexpr auto MaximumCount() noexcept {
return maximumElements;
}
};

Range() -> Range<>;

} // namespace cljonic

#include <concepts>
#include <limits>

namespace cljonic {

template <SizeType MaxElements, typename T>
class Repeat {
static constexpr SizeType maximumElements{MaximumElements(MaxElements)};

static_assert(maximumElements == MaxElements,
              "Attempt to create a Repeat bigger than CljonicCollectionMaximumElementCount");

static constexpr SizeType m_elementCount{maximumElements};
static constexpr T m_elementDefault{T{}};
const T m_elementValue;

class RepeatIterator final {
SizeType m_count;
const T m_value;

public:
using value_type = T;

constexpr explicit RepeatIterator(const SizeType count, const T& value) noexcept
    : m_count{count}, m_value{value} {
}

[[nodiscard]] constexpr RepeatIterator(const RepeatIterator& other) noexcept = default;

[[nodiscard]] constexpr const T& operator*() const noexcept {
return m_value;
}

constexpr RepeatIterator& operator++() noexcept {
++m_count;
return *this;
}

[[nodiscard]] constexpr bool operator!=(const RepeatIterator& other) const noexcept {
return m_count != other.m_count;
}

constexpr RepeatIterator& operator=(const RepeatIterator& other) noexcept {
if(this != &other)
m_count = other.m_count;
return *this;
}
};

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Repeat>;
using size_type = SizeType;
using value_type = T;

constexpr explicit Repeat(const T& t) noexcept : m_elementValue{t} {
}

constexpr explicit Repeat(T&& t) noexcept : m_elementValue{std::forward<T>(t)} {
}

constexpr Repeat(const Repeat& other) noexcept = default;
constexpr Repeat(Repeat&& other) noexcept = default;

[[nodiscard]] constexpr bool operator==(const auto& other) const noexcept {
return AreEqualValues(this, other);
}

[[nodiscard]] constexpr RepeatIterator begin() noexcept {
return RepeatIterator{0, m_elementValue};
}

[[nodiscard]] constexpr RepeatIterator end() noexcept {
return RepeatIterator{m_elementCount, m_elementValue};
}

[[nodiscard]] constexpr RepeatIterator begin() const noexcept {
return RepeatIterator{0, m_elementValue};
}

[[nodiscard]] constexpr RepeatIterator end() const noexcept {
return RepeatIterator{m_elementCount, m_elementValue};
}

[[nodiscard]] constexpr static SizeType Count() noexcept {
return m_elementCount;
}

[[nodiscard]] constexpr const T& DefaultElement() const noexcept {
return m_elementDefault;
}

[[nodiscard]] static constexpr auto MaximumCount() noexcept {
return m_elementCount;
}
};

template <typename T>
Repeat(T) -> Repeat<CljonicCollectionMaximumElementCount, T>;

} // namespace cljonic

#include <concepts>
#include <cstring>
#include <initializer_list>
#include <type_traits>

namespace cljonic {
template <typename T, SizeType MaxElements>
class Set {
static_assert(not std::floating_point<T>,
              "Floating point types should not be compared for equality, hence Sets of floating point types are "
              "not allowed");

static_assert(std::equality_comparable<T>, "A Set type must be equality comparable");

static constexpr SizeType maximumElements{MaximumElements(MaxElements)};

static_assert(maximumElements == MaxElements,
              "Attempt to create a Set bigger than CljonicCollectionMaximumElementCount");

SizeType m_elementCount{0};
const T m_elementDefault{T{}};
std::array<T, maximumElements> m_elements{};

class SetIterator final {
const T* m_elementsPointer;

public:
using value_type = T;

constexpr explicit SetIterator(const T* elementsPointer) noexcept : m_elementsPointer{elementsPointer} {
}

[[nodiscard]] constexpr const T& operator*() const noexcept {
return *m_elementsPointer;
}

constexpr SetIterator& operator++() noexcept {
++m_elementsPointer;
return *this;
}

[[nodiscard]] constexpr bool operator!=(const SetIterator& other) const noexcept {
return m_elementsPointer != other.m_elementsPointer;
}
};

[[nodiscard]] constexpr bool IsUniqueElement(const T& element) const noexcept {
const auto endIt{m_elements.begin() + m_elementCount};
for(auto it{m_elements.begin()}; it != endIt; ++it)
if(AreEqualValues(element, *it))
return false;
return true;
}

template <typename F, typename E>
[[nodiscard]] constexpr bool IsUniqueElementBy(F&& f, E&& element) const noexcept {
const auto endIt{m_elements.begin() + m_elementCount};
for(auto it{m_elements.begin()}; it != endIt; ++it)
if(AreEqualValuesBy(std::forward<F>(f), std::forward<E>(element), *it))
return false;
return true;
}

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Set>;
using size_type = SizeType;
using value_type = T;

constexpr Set() noexcept = default;

constexpr Set(const std::initializer_list<const T> elements) noexcept : m_elementCount(0), m_elementDefault(T{}) {

for(const auto& element : elements) {
if(m_elementCount == MaximumCount())
break;
if(IsUniqueElement(element))
m_elements[m_elementCount++] = element;
}
}

constexpr Set(const Set& other) noexcept = default;
constexpr Set(Set&& other) noexcept = default;

[[nodiscard]] constexpr T operator()(const T& t) const noexcept {
return Contains(t) ? t : m_elementDefault;
}

[[nodiscard]] constexpr bool operator==(const auto& other) const noexcept {
return AreEqualValues(this, other);
}

[[nodiscard]] constexpr SetIterator begin() noexcept {
return SetIterator{m_elements.data()};
}

[[nodiscard]] constexpr SetIterator end() noexcept {
return SetIterator{m_elements.data() + m_elementCount};
}

[[nodiscard]] constexpr SetIterator begin() const noexcept {
return SetIterator{m_elements.data()};
}

[[nodiscard]] constexpr SetIterator end() const noexcept {
return SetIterator{m_elements.data() + m_elementCount};
}

[[nodiscard]] constexpr SizeType Count() const noexcept {
return m_elementCount;
}

[[nodiscard]] constexpr bool Contains(const T& element) const noexcept {
return not IsUniqueElement(element);
}

template <typename F, typename E>
[[nodiscard]] constexpr bool ContainsBy(F&& f, E&& element) const noexcept {
return not IsUniqueElementBy(std::forward<F>(f), std::forward<E>(element));
}

[[nodiscard]] constexpr int DefaultElement() const noexcept {
return m_elementDefault;
}

[[nodiscard]] static constexpr SizeType MaximumCount() noexcept {
return maximumElements;
}
};

template <typename... Args>
Set(Args...) -> Set<std::common_type_t<Args...>, sizeof...(Args)>;

template <typename T = int>
Set() -> Set<T, 0>;

} // namespace cljonic

#include <algorithm>
#include <cstring>
#include <initializer_list>
#include <string_view>
#include <type_traits>

namespace cljonic {

template <SizeType MaxElements>
class String {
static constexpr SizeType maximumElements{MaximumElements(MaxElements)};

static_assert(maximumElements == MaxElements,
              "Attempt to create a String bigger than CljonicCollectionMaximumElementCount");

SizeType m_elementCount{0};
static constexpr CharType m_elementDefault{'\0'};
std::array<CharType, (maximumElements + 1)> m_elements{};

class StringIterator final {
const CharType* m_elementsPointer;

public:
using value_type = CharType;

constexpr explicit StringIterator(const CharType* elementsPointer) noexcept : m_elementsPointer{elementsPointer} {
}

[[nodiscard]] constexpr const CharType& operator*() const noexcept {
return *m_elementsPointer;
}

constexpr StringIterator& operator++() noexcept {
++m_elementsPointer;
return *this;
}

[[nodiscard]] constexpr bool operator!=(const StringIterator& other) const noexcept {
return m_elementsPointer != other.m_elementsPointer;
}
};

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::String>;
using size_type = SizeType;
using value_type = CharType;

constexpr String() noexcept : m_elementCount(0) {
m_elements[0] = '\0';
}

constexpr String(const std::initializer_list<CharType>& init) noexcept
    : m_elementCount{std::min(init.size(), maximumElements)} {
std::copy(init.begin(), {init.begin() + m_elementCount}, m_elements.begin());
m_elements[m_elementCount] = '\0';
}

constexpr explicit String(const CharType* str) noexcept
    : m_elementCount{std::min(std::strlen(str), maximumElements)} {
auto strView{std::string_view{str}};
std::copy(strView.begin(), {strView.begin() + m_elementCount}, m_elements.begin());
m_elements[m_elementCount] = '\0';
}

constexpr String(const String& other) noexcept = default;
constexpr String(String&& other) noexcept = default;

[[nodiscard]] constexpr bool operator==(const auto& other) const noexcept {
return AreEqualValues(this, other);
}

[[nodiscard]] constexpr StringIterator begin() noexcept {
return StringIterator{m_elements.data()};
}

[[nodiscard]] constexpr StringIterator end() noexcept {
return StringIterator{m_elements.data() + m_elementCount};
}

[[nodiscard]] constexpr StringIterator begin() const noexcept {
return StringIterator{m_elements.data()};
}

[[nodiscard]] constexpr StringIterator end() const noexcept {
return StringIterator{m_elements.data() + m_elementCount};
}

[[nodiscard]] constexpr CharType operator()(const SizeType index) const noexcept {
return (index < m_elementCount) ? m_elements[index] : m_elementDefault;
}

[[nodiscard]] constexpr const CharType* c_str() const noexcept {
return m_elements.data();
}

[[nodiscard]] constexpr SizeType Count() const noexcept {
return m_elementCount;
}

[[nodiscard]] constexpr CharType DefaultElement() const noexcept {
return m_elementDefault;
}

[[nodiscard]] static constexpr SizeType MaximumCount() noexcept {
return maximumElements;
}
};

template <SizeType N>
String(const CharType (&)[N]) -> String<N - 1>;

template <typename... Args>
String(Args...) -> String<sizeof...(Args)>;

} // namespace cljonic
namespace cljonic {

namespace core {
}

}

#include <utility>

namespace cljonic {

namespace core {

template <typename F1, typename F2, typename... Args>
concept ComposeIsCallableWith = requires(F1 f1, F2 f2, Args&&... args) {
{ f1(f2(std::forward<Args>(args)...)) };
};

template <typename F1, typename F2>
constexpr auto Compose(F1&& f1, F2&& f2) noexcept {
return [f1 = std::forward<F1>(f1), f2 = std::forward<F2>(f2)]<typename... T>(T&&... args) {
static_assert(ComposeIsCallableWith<F1, F2, T...>,
              "Each Compose argument must be callable with one argument of the return type of the argument to "
              "its right. Was the Compose result function called with the correct number of arguments?");

return f1(f2(std::forward<T>(args)...));
};
}
template <typename F1, typename F2, typename... Fs>
constexpr auto Compose(F1&& f1, F2&& f2, Fs&&... fs) noexcept {
return Compose(std::forward<F1>(f1), Compose(std::forward<F2>(f2), std::forward<Fs>(fs)...));
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C, typename... Cs>
constexpr auto Concat(const C& c, const Cs&... cs) noexcept {

static_assert(AllCljonicCollections<C, Cs...>, "All Concat parameters must be cljonic collections");

static_assert(AllConvertibleValueTypes<C, Cs...>,
              "All Concat cljonic collection value types must be interconvertible");

using ResultType = CommonValueType<C, Cs...>;

constexpr auto count{SumOfCljonicCollectionMaximumCounts<C, Cs...>()};
auto result{Array<ResultType, count>{}};
const auto MConjCollectionOntoResult = [&](const auto& c) {
for(const auto& v : c)
MConj(result, static_cast<ResultType>(v));
};
(MConjCollectionOntoResult(c), ..., MConjCollectionOntoResult(cs));
return result;
}

constexpr auto Concat() noexcept {
return Array<int, 0>{};
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C, typename... Es>
constexpr auto Conj(const C& c, const Es&... es) noexcept {

static_assert(IsCljonicCollection<C>, "First Conj parameter must be a cljonic collection");

static_assert(AllConvertibleTypes<typename C::value_type, Es...>,
              "Second through last Conj parameters must be convertible to cljonic collection value type");

using ResultType = typename C::value_type;

constexpr auto count{C::MaximumCount() + sizeof...(Es)};
auto result{Array<ResultType, count>{}};
const auto MConjElementOntoResult = [&](const auto& e) { MConj(result, e); };
for(const auto& e : c)
MConjElementOntoResult(e);
(MConjElementOntoResult(es), ...);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Count(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Count's parameter must be a cljonic collection");

return c.Count();
}

}

} // namespace cljonic::core

#include <utility>

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Cycle(const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "Cycle's parameter must be a cljonic collection");

auto defaultElement{c.DefaultElement()};
auto empty{0 == c.Count()};
auto initialElement{empty ? defaultElement : *c.begin()};
return Iterator{[collection = std::move(c), defaultElement, empty, initialized = false, it = c.begin()]([[maybe_unused]] const int _) mutable noexcept {
                auto NextElement =
                    [&, collectionBegin = collection.begin(), collectionEnd = collection.end()]() noexcept {
                    if(not initialized) {
                    it = collection.begin();
                    initialized = true;
                    }
                    ++it;
                    if(not(collectionEnd != it))
                    it = collectionBegin;
                    return *it;
                    };
                return empty ? defaultElement : NextElement();
                },
                initialElement};
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Dedupe(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Dedupe's parameter must be a cljonic collection");

static_assert((not std::floating_point<typename C::value_type>),
              "Dedupe should not compare cljonic floating point collection value types for equality. Consider "
              "using DedupeBy to override this default.");

return DedupeBy([](const auto& a, const auto& b) { return AreEqualValues(a, b); }, c);
}

}

} // namespace cljonic::core

#include <optional>

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto DedupeBy(F&& f, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "DedupeBy's second parameter must be a cljonic collection");

static_assert(IsBinaryPredicate<std::decay_t<F>, typename C::value_type, typename C::value_type>,
              "DedupeBy's function is not a valid binary predicate for the collection value type");

using ValueType = typename C::value_type;
using OptionalValueType = std::optional<ValueType>;

auto result{Array<ValueType, c.MaximumCount()>{}};
auto lastValue{OptionalValueType{std::nullopt}};
for(const auto& v : c) {
if(not lastValue) {
MConj(result, v);
lastValue = v;
} else if(not f(*lastValue, v)) {
MConj(result, v);
lastValue = v;
}
}
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto DefaultElement(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "DefaultElement's parameter must be a cljonic collection");

return c.DefaultElement();
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Drop(const SizeType count, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "Drop's second parameter must be a cljonic collection");

auto result{Array<typename C::value_type, c.MaximumCount()>{}};
auto dropCount{SizeType{0}};
const auto cEnd{c.end()};
for(auto it{c.begin()}; it != cEnd; ++it)
if(dropCount < count)
++dropCount;
else
MConj(result, *it);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto DropLast(const SizeType count, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "DropLast's second parameter must be a cljonic collection");

auto result{Array<typename C::value_type, c.MaximumCount()>{}};
auto takeCount{(count > c.Count()) ? 0 : (c.Count() - count)};
for(auto it{c.begin()}; (takeCount > 0); ++it) {
MConj(result, *it);
--takeCount;
}
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto DropWhile(F&& f, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "DropWhile's second parameter must be a cljonic collection");

static_assert(IsUnaryPredicate<std::decay_t<F>, typename C::value_type>,
              "DropWhile's function is not a valid unary predicate for the collection value type");

auto result{Array<typename C::value_type, c.MaximumCount()>{}};
auto conjElement(false);
for(const auto& element : c)
if(conjElement |= (not f(element)))
MConj(result, element);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename T, typename... Ts>
constexpr auto Equal(const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) == 0) {
if constexpr(IsCljonicCollection<T>)
static_assert((not std::floating_point<typename T::value_type>),
              "Equal should not compare cljonic floating point collection value types for equality. "
              "Consider using EqualBy to override this default.");
else
static_assert((not std::floating_point<T>),
              "Equal should not compare floating point types for equality. Consider using EqualBy to "
              "override this default.");
return true;
} else if constexpr(AllCljonicCollections<T, Ts...>) {
static_assert(not AnyFloatingPointValueTypes<T, Ts...>,
              "Equal should not compare cljonic floating point collection value types for equality. Consider "
              "using EqualBy to override this default.");

static_assert(AllSameCljonicCollectionType<T, Ts...> or AllCljonicNonSet<T, Ts...>,
              "Equal cljonic collection types are not all the same, or all Array, Range or Repeat types");

auto AllCountsEqual = [](const auto tCount, const auto&... ts) { return ((ts.Count() == tCount) and ...); };
auto AllValuesEqual = [](const auto& t, const auto&... ts) { return (AreEqualValues(t, ts) and ...); };
return AllCountsEqual(t.Count(), ts...) and AllValuesEqual(t, ts...);
} else {
static_assert(not AnyFloatingPointTypes<T, Ts...>,
              "Equal should not compare floating point types for equality. Consider using EqualBy to override "
              "this default.");

static_assert(AllEqualityComparableTypes<T, Ts...>, "Not all Equal types are equality comparable");

return (AreEqualValues(t, ts) and ...);
}
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename T, typename... Ts>
constexpr auto EqualBy(F&& f, const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) <= 0) {
return true;
} else if constexpr(AllCljonicCollections<T, Ts...>) {
static_assert(AllSameCljonicCollectionType<T, Ts...> or AllCljonicNonSet<T, Ts...>,
              "EqualBy cljonic collection types are not all the same, or all Array, Range or Repeat types");

static_assert(IsBinaryPredicateForAllCljonicCollections<std::decay_t<F>, T, Ts...>,
              "EqualBy function is not a valid binary predicate for all cljonic collection value types");

auto AllCountsEqual = [](const auto tCount, const auto&... ts) { return ((ts.Count() == tCount) and ...); };
auto AllValuesEqualBy = [](F&& f, const auto& t, const auto&... ts) { return (AreEqualValuesBy(f, t, ts) and ...); };

return AllCountsEqual(t.Count(), ts...) and AllValuesEqualBy(f, t, ts...);
} else {
static_assert(AllEqualityComparableTypes<T, Ts...>, "Not all EqualBy types are equality comparable");

static_assert(IsBinaryPredicateForAll<F, T, Ts...>,
              "EqualBy function is not a valid binary predicate for all parameters");

return (AreEqualValuesBy(f, t, ts) and ...);
}
}

}

} // namespace cljonic::core

#include <array>

namespace cljonic {

namespace core {

template <typename T, typename... Ts>
constexpr auto InnerIsDistinct(const T& t, const Ts&... ts) noexcept {
if constexpr(sizeof...(Ts) == 0) {
return true;
} else {
return ((not AreEqualValues(t, ts)) and ... and (InnerIsDistinct(ts...)));
}
}
template <typename T, typename... Ts>
constexpr auto IsDistinct(const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) == 0) {
if constexpr(IsNotCljonicCollection<T> or IsCljonicSet<T>) {
return true;
} else {
static_assert(not std::floating_point<typename T::value_type>,
              "IsDistinct should not compare cljonic floating point collection value types for equality. "
              "Consider using IsDistinctBy to override this default.");

return AreUniqueValues<decltype(t.begin()), T::MaximumCount()>(t.begin(), t.end());
}
} else {
static_assert(not AnyFloatingPointOrFloatingPointValueType<T, Ts...>,
              "IsDistinct should not compare floating point types for equality. Consider using IsDistinctBy to "
              "override this default.");

return InnerIsDistinct(t, ts...);
}
}

}

} // namespace cljonic::core

#include <utility>

namespace cljonic {

namespace core {

template <typename F, typename T, typename... Ts>
constexpr auto InnerIsDistinctBy(F&& f, const T& t, const Ts&... ts) noexcept {
if constexpr(sizeof...(Ts) == 0) {
return true;
} else {
return ((not AreEqualValuesBy(std::forward<F>(f), t, ts)) and ... and
        (InnerIsDistinctBy(std::forward<F>(f), ts...)));
}
}
template <typename F, typename T, typename... Ts>
constexpr auto IsDistinctBy(F&& f, const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) == 0) {
if constexpr(IsNotCljonicCollection<T> or IsCljonicSet<T>) {
return true;
} else {
static_assert(IsBinaryPredicate<std::decay_t<F>, typename T::value_type, typename T::value_type>,
              "IsDistinctBy function is not a valid binary predicate for cljonic collection value type");

return AreUniqueValuesBy<F, decltype(t.begin()), T::MaximumCount()>(std::forward<F>(f), t.begin(), t.end());
}
} else {
return InnerIsDistinctBy(std::forward<F>(f), t, ts...);
}
}

}

} // namespace cljonic::core

#endif // CLJONIC_H_
