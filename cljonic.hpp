#ifndef CLJONIC_H_
#define CLJONIC_H_

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT EDIT THIS FILE.  IT IS AUTOMATICALLY GENERATED BY INVOKING 'make cljonic' WITHIN THE cljonic DIRECTORY.
//
// TO UPDATE THIS FILE, MAKE CHANGES TO THE FILES IN THE code/source DIRECTORY.
//
// ONLY cljonic DEVELOPERS SHOULD MAKE CHANGES.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) Paul Whittington All rights reserved. The use and distribution terms for this software are covered by
// the Apache License Version 2.0, January 2004 (http://www.apache.org/licenses/LICENSE-2.0). By using this software in
// any fashion, you are agreeing to be bound by the terms of this license. You must not remove this notice, or any
// other, from this software.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// This file was generated Wed Feb 12 02:09:52 PM MST 2025

#ifndef CLJONIC_COLLECTION_MAXIMUM_ELEMENT_COUNT_HPP
#define CLJONIC_COLLECTION_MAXIMUM_ELEMENT_COUNT_HPP

#include <cstddef>
#include <limits>

namespace cljonic {

using SizeType = std::size_t;

constexpr SizeType operator"" _sz(unsigned long long int value) {
return static_cast<SizeType>(value);
}

constexpr auto CljonicCollectionMaximumElementCount{1000_sz};

constexpr auto CljonicInvalidIndex{CljonicCollectionMaximumElementCount};

} // namespace cljonic

#endif // CLJONIC_COLLECTION_MAXIMUM_ELEMENT_COUNT_HPP

namespace cljonic {

template <typename T>
class CollectionIterator {
const T& m_collection;
SizeType m_index;

public:
constexpr CollectionIterator(const T& collection, const SizeType index) noexcept
    : m_collection(collection), m_index(index) {
}

constexpr auto operator*() const noexcept -> decltype(m_collection[m_index]) {
return m_collection[m_index];
}

constexpr CollectionIterator& operator++() noexcept {
++m_index;
return *this;
}

constexpr CollectionIterator operator++(int) noexcept {
auto result{*this};
++(*this);
return result;
}

constexpr CollectionIterator& operator--() noexcept {
--m_index;
return *this;
}

constexpr bool operator!=(const CollectionIterator& other) const noexcept {
return m_index != other.m_index;
}

constexpr CollectionIterator& operator+=(SizeType value) noexcept {
m_index += value;
return *this;
}

constexpr CollectionIterator operator+(SizeType value) const noexcept {
auto result{*this};
result += value;
return result;
}

constexpr CollectionIterator& operator-=(SizeType value) noexcept {
m_index -= value;
return *this;
}

constexpr CollectionIterator operator-(SizeType value) const noexcept {
auto result{*this};
result -= value;
return result;
}
};

} // namespace cljonic

namespace cljonic {

enum class CljonicCollectionType {
    Array,
    Cycle,
    Iterator,
    Range,
    Repeat,
    Set,
    String
};

}

#include <concepts>
#include <limits>
#include <type_traits>

namespace inner_find_common_type {

template <typename T, typename... Ts>
struct InnerFindCommonType;

template <typename T>
struct InnerFindCommonType<T> {
using type = T;
};

template <typename T, typename U, typename... Ts>
struct InnerFindCommonType<T, U, Ts...> {

using type = std::conditional_t<(std::convertible_to<U, T> && ... && std::convertible_to<Ts, T>),
                                typename InnerFindCommonType<T, Ts...>::type,
                                typename InnerFindCommonType<U, Ts...>::type>;
};

} // namespace inner_find_common_type

namespace cljonic {

using namespace inner_find_common_type;

template <typename T>
concept IsArithmetic = std::integral<T> or std::floating_point<T>;

template <typename P, typename T, typename U>
concept IsBinaryPredicate = requires(P p, T a, U b) {
{ p(a, b) } -> std::convertible_to<bool>;
};

template <typename P, typename T, typename... Ts>
concept IsBinaryPredicateForAll = (IsBinaryPredicate<P, T, Ts> && ...);

template <typename T>
concept IsCljonicArray = std::same_as<typename T::cljonic_collection_type,
                                      std::integral_constant<CljonicCollectionType, CljonicCollectionType::Array>>;

template <typename T>
concept IsCljonicCollection = requires { typename T::cljonic_collection_type; };

template <typename T>
concept IsCljonicIterator =
    std::same_as<typename T::cljonic_collection_type,
                 std::integral_constant<CljonicCollectionType, CljonicCollectionType::Iterator>>;

template <typename T>
concept IsCljonicRange = std::same_as<typename T::cljonic_collection_type,
                                      std::integral_constant<CljonicCollectionType, CljonicCollectionType::Range>>;

template <typename T>
concept IsCljonicRepeat = std::same_as<typename T::cljonic_collection_type,
                                       std::integral_constant<CljonicCollectionType, CljonicCollectionType::Repeat>>;

template <typename T>
concept IsCljonicSet = std::same_as<typename T::cljonic_collection_type,
                                    std::integral_constant<CljonicCollectionType, CljonicCollectionType::Set>>;

template <typename T>
concept IsCljonicArrayRangeOrRepeat = IsCljonicArray<T> or IsCljonicRange<T> or IsCljonicRepeat<T>;

template <typename T>
concept IsConvertibleToIntegral = std::convertible_to<T, char> or std::convertible_to<T, short> or std::convertible_to<T, int> or std::convertible_to<T, long> or std::convertible_to<T, long long>;
template <typename T>
concept IsCString = std::same_as<std::decay_t<T>, char*> or std::same_as<std::decay_t<T>, const char*>;

template <typename T>
concept IsNotCljonicCollection = not IsCljonicCollection<T>;

template <typename P, typename T>
concept IsUnaryFunction = requires(P p, T t) {
{ p(t) } -> std::convertible_to<T>;
};

template <typename P, typename T>
concept IsUnaryPredicate = requires(P p, T t) {
{ p(t) } -> std::convertible_to<bool>;
};

template <typename T, typename... Ts>
concept AllCljonicArrayRangeOrRepeat = (IsCljonicArrayRangeOrRepeat<T> and ... and IsCljonicArrayRangeOrRepeat<Ts>);

template <typename T, typename... Ts>
concept AllCljonicCollections = (IsCljonicCollection<T> and ... and IsCljonicCollection<Ts>);

template <typename T, typename... Ts>
concept AllCljonicSets = (IsCljonicSet<T> and ... and IsCljonicSet<Ts>);

template <typename T, typename... Ts>
constexpr bool AllConvertibleTypes = (std::convertible_to<T, Ts> and ...);

template <typename T, typename... Ts>
constexpr bool AllConvertibleValueTypes =
    (AllConvertibleTypes<typename T::value_type, typename Ts::value_type> and ...);

template <typename T, typename... Ts>
constexpr bool AllEqualityComparableTypes = (std::equality_comparable_with<T, Ts> and ...);

template <typename T, typename... Ts>
constexpr bool AllEqualityComparableValueTypes =
    (std::equality_comparable_with<typename T::value_type, typename Ts::value_type> and ...);

template <typename T, typename... Ts>
constexpr bool AnyFloatingPointTypes = (std::floating_point<T> or ... or std::floating_point<Ts>);

template <typename T, typename... Ts>
concept AllNotCljonicCollections = (IsNotCljonicCollection<T> and ... and IsNotCljonicCollection<Ts>);

template <typename T, typename... Ts>
concept AllSameCljonicCollectionType =
    (std::same_as<typename T::cljonic_collection_type, typename Ts::cljonic_collection_type> and ...);

template <typename T, typename... Ts>
constexpr bool AnyFloatingPointValueTypes =
    (std::floating_point<typename T::value_type> or ... or std::floating_point<typename Ts::value_type>);

template <typename T, typename... Ts>
using FindCommonType = typename InnerFindCommonType<T, Ts...>::type;

template <typename T, typename... Ts>
using FindCommonValueType = typename InnerFindCommonType<typename T::value_type, typename Ts::value_type...>::type;

template <typename F, IsCljonicCollection T, IsCljonicCollection... Ts>
constexpr bool IsBinaryPredicateForAllCljonicCollections =
    (IsBinaryPredicateForAll<F, typename T::value_type, typename Ts::value_type> and ...);

} // namespace cljonic

#include <concepts>
#include <cstring>
#include <limits>

namespace cljonic {

template <typename T>
class IndexInterface {
public:
virtual constexpr SizeType Count() const noexcept = 0;
virtual constexpr T operator[](const SizeType index) const noexcept = 0;
virtual constexpr bool ElementAtIndexIsEqualToElement(const SizeType index, const T& element) const noexcept = 0;
};

template <typename F, typename T, typename U>
constexpr bool AreEqualBy(F&& f, const T& t, const U& u) noexcept {

if constexpr(IsCljonicCollection<T> and IsCljonicCollection<U>) {
auto result{t.Count() == u.Count()};
auto tBegin{t.begin()};
auto tEnd{t.end()};
auto uIt{u.begin()};
for(auto it{tBegin}; (result and (it != tEnd)); ++it, ++uIt)
result = f(*it, *uIt);
return result;
} else {
return f(t, u);
}
}

template <typename T, typename U>
constexpr bool AreEqual(const T& t, const U& u) noexcept {

if constexpr(IsCString<T> and IsCString<U>) {
return std::strcmp(t, u) == 0;
} else if constexpr(IsCljonicSet<T> or IsCljonicSet<U>) {
if constexpr(IsCljonicSet<T>) {
auto result{t.Count() == u.Count()};
auto uBegin{u.begin()};
auto uEnd{u.end()};
for(auto it{uBegin}; (result and (it != uEnd)); ++it)
result = t.Contains(*it);
return result;
} else {
auto result{t.Count() == u.Count()};
auto tBegin{t.begin()};
auto tEnd{t.end()};
for(auto it{tBegin}; (result and (it != tEnd)); ++it)
result = u.Contains(*it);
return result;
}
} else if constexpr(IsCljonicCollection<T> and IsCljonicCollection<U>) {
auto result{t.Count() == u.Count()};
auto tBegin{t.begin()};
auto tEnd{t.end()};
auto uIt{u.begin()};
for(auto it{tBegin}; (result and (it != tEnd)); ++it, ++uIt)
result = AreEqual(*it, *uIt);
return result;
} else if constexpr((not IsCljonicCollection<T>) and (not IsCljonicCollection<U>)) {
return t == u;
} else {
static_assert(false, "AreEqual arguments are not comparable");
}
}

template <typename T, typename U>
constexpr bool FirstLessThanSecond(const T& t, const U& u) noexcept {
if constexpr(IsCString<T> and IsCString<U>) {
return std::strcmp(t, u) < 0;
} else {
return t < u;
}
}

template <typename T, typename... Ts>
constexpr auto MinArgument(T a, Ts... args) noexcept {
if constexpr(sizeof...(args) == 0) {
return a;
} else {
return (a < MinArgument(args...)) ? a : MinArgument(args...);
}
}

template <typename C, typename... Cs>
constexpr auto MinimumOfCljonicCollectionMaximumCounts() {
if constexpr(sizeof...(Cs) == 0) {
return C::MaximumCount();
} else {
return (MinArgument(C::MaximumCount(), Cs::MaximumCount()), ...);
}
}

template <typename C, typename... Cs>
constexpr auto SumOfCljonicCollectionMaximumCounts() {
if constexpr(sizeof...(Cs) == 0) {
return C::MaximumCount();
} else {
return (C::MaximumCount() + ... + Cs::MaximumCount());
}
}

constexpr SizeType MaximumElements(const SizeType count) noexcept {
return MinArgument(count, CljonicCollectionMaximumElementCount);
}

} // namespace cljonic

namespace cljonic {

template <typename T, SizeType MaxElements>
class Array;

template <typename F, typename T>
class Iterator;

template <int... StartEndStep>
class Range;

template <SizeType MaxElements, typename T>
class Repeat;

template <typename T, SizeType MaxElements>
class Set;

template <SizeType MaxElements>
class String;

namespace core {

template <typename F1, typename F2>
constexpr auto Compose(F1&& f1, F2&& f2) noexcept;

constexpr auto Concat() noexcept;

template <typename C, typename... Cs>
constexpr auto Concat(const C& c, const Cs&... cs) noexcept;

template <typename C, typename... Es>
constexpr auto Conj(const C& c, const Es&... es) noexcept;

template <typename C>
constexpr auto Count(const C& c) noexcept;

template <typename C>
constexpr auto Cycle(const C& c) noexcept;

template <typename C>
constexpr auto Dedupe(const C& c) noexcept;

template <typename F, typename C>
constexpr auto DedupeBy(F&& f, const C& c) noexcept;

template <typename C>
constexpr auto DefaultElement(const C& c) noexcept;

template <typename C>
constexpr auto Drop(const SizeType count, const C& c) noexcept;

template <typename C>
constexpr auto DropLast(const SizeType count, const C& c) noexcept;

template <typename F, typename C>
constexpr auto DropWhile(F&& f, const C& c) noexcept;

template <typename T, typename... Ts>
constexpr auto Equal(const T& t, const Ts&... ts) noexcept;

template <typename F, typename T, typename... Ts>
constexpr auto EqualBy(F&& f, const T& t, const Ts&... ts) noexcept;

template <typename F, typename C>
constexpr auto Every(F&& f, const C& c) noexcept;

template <typename F, typename C>
constexpr auto Filter(F&& f, const C& c) noexcept;

template <typename C>
constexpr auto First(const C& c) noexcept;

template <typename T, typename... Ts>
constexpr auto Identical(const T& t, const Ts&... ts) noexcept;

template <typename T>
constexpr void* Identity(const T& t) noexcept;

template <typename T>
constexpr auto Inc(const T t) noexcept;

template <typename C, typename T>
constexpr auto IndexOf(const C& c, const T& t) noexcept;

template <typename F, typename C, typename T>
constexpr auto IndexOfBy(F&& f, const C& c, const T& t) noexcept;

constexpr auto Interleave() noexcept;

template <typename C, typename... Cs>
constexpr auto Interleave(const C& c, const Cs&... cs) noexcept;

template <typename T, typename C>
constexpr auto Interpose(const T& t, const C& c) noexcept;

template <typename T, typename... Ts>
constexpr bool IsDistinct(const T& t, const Ts&... ts) noexcept;

template <typename F, typename T, typename... Ts>
constexpr auto IsDistinctBy(F&& f, const T& t, const Ts&... ts) noexcept;

template <typename C>
constexpr auto IsEmpty(const C& c) noexcept;

template <typename C>
constexpr auto IsFull(const C& c) noexcept;

template <typename F, typename T>
constexpr auto Iterate(F&& f, const T& t) noexcept;

template <typename C>
constexpr auto Last(const C& c) noexcept;

template <typename C, typename T>
constexpr auto LastIndexOf(const C& c, const T& t) noexcept;

template <typename F, typename C, typename T>
constexpr auto LastIndexOfBy(F&& f, const C& c, const T& t) noexcept;

template <typename F, typename C, typename... Cs>
constexpr auto Map(F&& f, const C& c, const Cs&... cs) noexcept;

template <typename T, typename... Ts>
constexpr auto Max(const T& t, const Ts&... ts) noexcept;

template <typename F, typename T, typename... Ts>
constexpr auto MaxBy(F&& f, const T& t, const Ts&... ts) noexcept;

template <typename T, typename... Ts>
constexpr auto Min(const T& t, const Ts&... ts) noexcept;

template <typename F, typename T, typename... Ts>
constexpr auto MinBy(F&& f, const T& t, const Ts&... ts) noexcept;

template <typename F, typename C>
constexpr auto NotAny(F&& f, const C& c) noexcept;

template <typename F, typename C>
constexpr auto NotEvery(F&& f, const C& c) noexcept;

template <typename C>
constexpr auto Nth(const C& c, const SizeType index) noexcept;

template <typename C, typename T>
constexpr auto Nth(const C& c, const SizeType index, const T& t) noexcept;

template <typename F, typename... Args>
constexpr auto Partial(F&& f, Args&&... args) noexcept;

template <typename F, typename C>
constexpr auto Reduce(F&& f, const C& c) noexcept;

template <typename F, typename C>
constexpr auto Remove(F&& f, const C& c) noexcept;

template <typename C1, typename C2>
constexpr auto Replace(const C1& c1, const C2& c2) noexcept;

template <typename C>
constexpr auto Reverse(const C& c) noexcept;

template <typename C>
constexpr auto Second(const C& c) noexcept;

template <typename C>
constexpr auto Seq(const C& c) noexcept;

template <typename C>
constexpr auto Size(const C& c) noexcept;

template <typename F, typename C>
constexpr auto Some(F&& f, const C& c) noexcept;

template <typename F, typename C>
constexpr auto Sort(F&& f, const C& c) noexcept;

template <typename F, typename C>
constexpr auto SortBy(F&& f, const C& c) noexcept;

template <typename C>
constexpr auto SplitAt(const SizeType count, const C& c) noexcept;

template <typename F, typename C>
constexpr auto SplitWith(F&& f, const C& c) noexcept;

template <typename C>
constexpr auto Subs(const C& c, const SizeType start, const SizeType end) noexcept;

template <typename C>
constexpr auto Take(const SizeType count, const C& c) noexcept;

template <typename C>
constexpr auto TakeLast(const SizeType count, const C& c) noexcept;

template <typename C>
constexpr auto TakeNth(const SizeType nth, const C& c) noexcept;

template <typename F, typename C>
constexpr auto TakeWhile(F&& f, const C& c) noexcept;

} // namespace core

} // namespace cljonic

#include <cstring>
#include <initializer_list>
#include <type_traits>

namespace cljonic {

template <typename T, SizeType MaxElements>
class Array : public IndexInterface<T> {
static constexpr auto maximumElements{MaximumElements(MaxElements)};

static_assert(maximumElements == MaxElements,
              "Attempt to create an Array bigger than CljonicCollectionMaximumElementCount");

static constexpr auto elementCount{(0 == maximumElements) ? 1 : maximumElements};
SizeType m_elementCount;
T m_elementDefault;
T m_elements[elementCount]{};

constexpr auto ValueAtIndex(const SizeType index) const noexcept {
return (index < m_elementCount) ? m_elements[index] : m_elementDefault;
}

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Array>;
using size_type = SizeType;
using value_type = T;

constexpr Array() noexcept : m_elementCount(0), m_elementDefault(T{}) {
}

constexpr explicit Array(const std::initializer_list<const T> elements) noexcept
    : m_elementCount(MinArgument(MaximumCount(), elements.size())), m_elementDefault(T{}) {
for(SizeType i{0}; i < m_elementCount; ++i)
m_elements[i] = *(elements.begin() + i);
}

constexpr Array(const Array& other) = default;
constexpr Array(Array&& other) = default;

constexpr const T* begin() const noexcept {
return m_elements;
}

constexpr const T* end() const noexcept {
return m_elements + m_elementCount;
}

constexpr T operator[](const SizeType index) const noexcept override {
return ValueAtIndex(index);
}

constexpr T operator()(const SizeType index) const noexcept {
return this->operator[](index);
}

constexpr bool operator==(const auto& other) const noexcept {
return AreEqual(*this, other);
}

constexpr bool operator!=(const auto& other) const noexcept {
return not(*this == other);
}

constexpr Array& operator=(const Array& other) noexcept {
if(this != &other) {
m_elementCount = other.m_elementCount;
m_elementDefault = other.m_elementDefault;
for(SizeType i{0}; i < m_elementCount; ++i)
m_elements[i] = other.m_elements[i];
}
return *this;
}

[[nodiscard]] constexpr SizeType Count() const noexcept override {
return m_elementCount;
}

constexpr const T& DefaultElement() const noexcept {
return m_elementDefault;
}

constexpr bool ElementAtIndexIsEqualToElement(const SizeType index, const T& element) const noexcept override {
return (index < m_elementCount) and AreEqual(ValueAtIndex(index), element);
}

static constexpr SizeType MaximumCount() noexcept {
return maximumElements;
}

constexpr void MAppend(const T& value) {
if(m_elementCount < maximumElements)
m_elements[m_elementCount++] = value;
}

constexpr T* MPtr(const SizeType index) {
return (index < m_elementCount) ? &m_elements[index] : &m_elementDefault;
}

constexpr void MReverse() {
if(m_elementCount >= 2)
for(auto start{0_sz}, end{m_elementCount - 1_sz}; start < end; ++start, --end)
std::swap(m_elements[start], m_elements[end]);
}

constexpr void MSet(const T& value, const SizeType index) {
if(index < m_elementCount)
m_elements[index] = value;
}

template <typename F>
constexpr void MSortBy(F&& f) noexcept {

if(m_elementCount > 1) {

for(SizeType i{1}; i < m_elementCount; ++i) {
auto key{m_elements[i]};
auto j{i + 1};
while((--j > 0) and f(key, m_elements[j - 1]))
m_elements[j] = m_elements[j - 1];
m_elements[j] = key;
}
}
}

constexpr void MSort() noexcept {
MSortBy([](const T& lhs, const T& rhs) { return FirstLessThanSecond(lhs, rhs); });
}
};

template <typename... Args>
Array(Args...) -> Array<std::common_type_t<Args...>, sizeof...(Args)>;

} // namespace cljonic

#include <concepts>
#include <utility>

namespace cljonic {
template <typename F, typename T>
class Iterator {
T m_elementDefault;
F m_f;
T m_initialValue;

class Itr {
F m_f;
SizeType m_index;
T m_nextValue;

public:
using value_type = T;
using difference_type = std::ptrdiff_t;
using pointer = T*;
using reference = T&;

Itr(const Iterator& iterator, SizeType index)
    : m_f{iterator.m_f}, m_index{index}, m_nextValue{iterator.m_initialValue} {
}

T operator*() const {
return m_nextValue;
}

Itr& operator++() {
if(m_index < Iterator::MaximumCount()) {
m_nextValue = m_f(m_nextValue);
++m_index;
}
return *this;
}

Itr operator++(int) {
auto result{*this};
++(*this);
return result;
}

Itr operator+(SizeType n) const {
auto result{*this};
for(SizeType i{0}; (i < n) and (result.m_index < Iterator::MaximumCount()); ++i)
++result;
return result;
}

Itr operator-(SizeType n) const {
auto result{*this};
result.m_index = (m_index > n) ? (m_index - n) : 0;
return result;
}

bool operator!=(const Itr& other) const {
return m_index != other.m_index;
}
};

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Iterator>;
using size_type = SizeType;
using value_type = T;

constexpr explicit Iterator(F&& f, const T& t) noexcept : m_f{std::forward<F>(f)}, m_initialValue{t} {
static_assert(IsUnaryFunction<F, T>,
              "Iterator constructor's first parameter is not a unary function of its second parameter");
}

constexpr Iterator(const Iterator& other) = default;
constexpr Iterator(Iterator&& other) = default;

Itr begin() const {
return Itr(*this, 0);
}

Itr end() const {
return Itr(*this, MaximumCount());
}

constexpr bool operator==(const auto& other) const noexcept {
return AreEqual(*this, other);
}

constexpr bool operator!=(const auto& other) const noexcept {
return not(*this == other);
}

[[nodiscard]] constexpr SizeType Count() const noexcept {
return CljonicCollectionMaximumElementCount;
}

constexpr const T& DefaultElement() const noexcept {
return m_elementDefault;
}

[[nodiscard]] static constexpr auto MaximumCount() noexcept {
return CljonicCollectionMaximumElementCount;
}
};

template <typename F, typename T>
Iterator(F&&, const T&) -> Iterator<F, T>;

} // namespace cljonic

#include <concepts>

namespace cljonic {

template <int... StartEndStep>
class Range : public IndexInterface<int> {
private:
static_assert(sizeof...(StartEndStep) <= 3, "Number of Range parameters must be less than or equal to three");

using Iterator = CollectionIterator<Range>;

SizeType m_elementCount;
int m_elementDefault;
int m_elementStart;
int m_elementStep;

static constexpr auto RangeCount(const int start, const int end, const int step) noexcept {
return (0 == step) ? 0 : ((end - start) / step) + ((((end - start) % step) == 0) ? 0 : 1);
}

static constexpr int values[] = {StartEndStep...};

static constexpr auto MaxElements = []() constexpr {
if constexpr(sizeof...(StartEndStep) == 1) {
if constexpr(values[0] < 0)
return 0_sz;
else
return static_cast<SizeType>(values[0]);
} else if constexpr(sizeof...(StartEndStep) == 2) {
if constexpr(values[1] <= values[0])
return 0_sz;
else
return static_cast<SizeType>(values[1] - values[0]);
} else if constexpr(sizeof...(StartEndStep) == 3) {

if constexpr((0 == values[2]) and (values[0] == values[1]))
return 0_sz;
else if constexpr(0 == values[2])
return CljonicCollectionMaximumElementCount;
else if constexpr(values[2] < 0) {
if constexpr(values[0] <= values[1])
return 0_sz;
else
return static_cast<SizeType>(RangeCount(values[0], values[1], values[2]));
} else {
if constexpr(values[1] <= values[0])
return 0_sz;
else
return static_cast<SizeType>(RangeCount(values[0], values[1], values[2]));
}
} else {
return CljonicCollectionMaximumElementCount;
}
}();

static constexpr SizeType maximumElements{MaximumElements(MaxElements)};

static_assert(maximumElements == MaxElements,
              "Attempt to create a Range bigger than CljonicCollectionMaximumElementCount");

constexpr void InitializeMembers(const int count, const int start, const int step) noexcept {
m_elementCount = MinArgument(static_cast<SizeType>(count), CljonicCollectionMaximumElementCount);
m_elementDefault = 0;
m_elementStart = start;
m_elementStep = step;
}

constexpr void Initialize() noexcept {
InitializeMembers(CljonicCollectionMaximumElementCount, 0, 1);
}

constexpr void InitializeEnd(const int end) noexcept {
if(end <= 0)
InitializeMembers(0, 0, 1);
else
InitializeMembers(end, 0, 1);
}

constexpr void InitializeStartEnd(const int start, const int end) noexcept {
if(end <= start)
InitializeMembers(0, 0, 1);
else
InitializeMembers((end - start), start, 1);
}

constexpr void InitializeStartEndStepWithNegativeStep(const int start, const int end, const int step) noexcept {
if(start <= end)
InitializeMembers(0, 0, step);
else {
const int count{RangeCount(start, end, step)};
InitializeMembers(count, start, step);
}
}

constexpr void InitializeStartEndStepWithPositiveStep(const int start, const int end, const int step) noexcept {
if(end <= start)
InitializeMembers(0, 0, step);
else {
const int count{RangeCount(start, end, step)};
InitializeMembers(count, start, step);
}
}

constexpr void InitializeStartEndStep(const int start, const int end, const int step) noexcept {

if((0 == step) and (start == end))
InitializeMembers(0, 0, 0);
else if(0 == step)
InitializeMembers(CljonicCollectionMaximumElementCount, start, 0);
else if(step < 0)
InitializeStartEndStepWithNegativeStep(start, end, step);
else
InitializeStartEndStepWithPositiveStep(start, end, step);
}

constexpr auto ValueAtIndex(const SizeType index) const noexcept {
return ((0 == m_elementCount) or (index >= m_elementCount))
           ? m_elementDefault
           : (m_elementStart + (static_cast<int>(index) * m_elementStep));
}

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Range>;
using size_type = SizeType;
using value_type = int;

constexpr Range() noexcept
    : m_elementCount{static_cast<SizeType>(0)}, m_elementDefault{0}, m_elementStart{0}, m_elementStep{0} {

if constexpr(sizeof...(StartEndStep) == 1) {
InitializeEnd(values[0]);
} else if constexpr(sizeof...(StartEndStep) == 2) {
InitializeStartEnd(values[0], values[1]);
} else if constexpr(sizeof...(StartEndStep) == 3) {
InitializeStartEndStep(values[0], values[1], values[2]);
} else {
Initialize();
}
}

constexpr Range(const Range& other) = default;
constexpr Range(Range&& other) = default;

[[nodiscard]] constexpr Iterator begin() const noexcept {
return Iterator{*this, 0};
}

[[nodiscard]] constexpr Iterator end() const noexcept {
return Iterator{*this, m_elementCount};
}

constexpr int operator[](const SizeType index) const noexcept override {
return ValueAtIndex(index);
}

constexpr int operator()(const SizeType index) const noexcept {
return this->operator[](index);
}

constexpr bool operator==(const auto& other) const noexcept {
return AreEqual(*this, other);
}

constexpr bool operator!=(const auto& other) const noexcept {
return not(*this == other);
}

[[nodiscard]] constexpr SizeType Count() const noexcept override {
return m_elementCount;
}

constexpr int DefaultElement() const noexcept {
return m_elementDefault;
}

constexpr bool ElementAtIndexIsEqualToElement(const SizeType index, const int& element) const noexcept override {
return (index < m_elementCount) and AreEqual(ValueAtIndex(index), element);
}

static constexpr auto MaximumCount() noexcept {
return maximumElements;
}
};

Range() -> Range<>;

} // namespace cljonic

#include <concepts>
#include <limits>

namespace cljonic {

template <SizeType MaxElements, typename T>
class Repeat : public IndexInterface<T> {
using Iterator = CollectionIterator<Repeat>;

static constexpr SizeType maximumElements{MaximumElements(MaxElements)};

static_assert(maximumElements == MaxElements,
              "Attempt to create a Repeat bigger than CljonicCollectionMaximumElementCount");

const SizeType m_elementCount;
const T m_elementDefault;
const T m_elementValue;

constexpr auto ValueAtIndex(const SizeType index) const noexcept {
return ((m_elementCount <= 0) or (index >= m_elementCount)) ? m_elementDefault : m_elementValue;
}

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Repeat>;
using size_type = SizeType;
using value_type = T;

constexpr explicit Repeat(const T& t) noexcept
    : m_elementCount{maximumElements}, m_elementDefault{T{}}, m_elementValue{t} {
}

constexpr Repeat(const Repeat& other) = default;
constexpr Repeat(Repeat&& other) = default;

[[nodiscard]] constexpr Iterator begin() const noexcept {
return Iterator{*this, 0};
}

[[nodiscard]] constexpr Iterator end() const noexcept {
return Iterator{*this, m_elementCount};
}

constexpr T operator[](const SizeType index) const noexcept override {
return ValueAtIndex(index);
}

constexpr T operator()(const SizeType index) const noexcept {
return this->operator[](index);
}

constexpr bool operator==(const auto& other) const noexcept {
return AreEqual(*this, other);
}

constexpr bool operator!=(const auto& other) const noexcept {
return not(*this == other);
}

[[nodiscard]] constexpr SizeType Count() const noexcept override {
return m_elementCount;
}

constexpr const T& DefaultElement() const noexcept {
return m_elementDefault;
}

constexpr bool ElementAtIndexIsEqualToElement(const SizeType index, const T& element) const noexcept override {
return (index < m_elementCount) and AreEqual(ValueAtIndex(index), element);
}

static constexpr auto MaximumCount() noexcept {
return maximumElements;
}
};

template <typename T>
Repeat(T) -> Repeat<CljonicCollectionMaximumElementCount, T>;

} // namespace cljonic

#include <concepts>
#include <cstring>
#include <initializer_list>
#include <type_traits>
#include <utility>

namespace cljonic {
template <typename T, SizeType MaxElements>
class Set : public IndexInterface<T> {
static_assert(not std::floating_point<T>,
              "Floating point types should not be compared for equality, hence Sets of floating point types are "
              "not allowed");

static_assert(std::equality_comparable<T>, "A Set type must be equality comparable");

static constexpr SizeType maximumElements{MaximumElements(MaxElements)};

static_assert(maximumElements == MaxElements,
              "Attempt to create a Set bigger than CljonicCollectionMaximumElementCount");

SizeType m_elementCount;
const T m_elementDefault;
T m_elements[maximumElements]{};

constexpr bool IsUniqueElementBy(const auto& f, const T& element) const noexcept {
auto result{true};
for(SizeType i{0}; (result and (i < m_elementCount)); ++i)
result = not AreEqualBy(f, element, m_elements[i]);
return result;
}

constexpr bool IsUniqueElement(const T& element) const noexcept {
auto result{true};
for(SizeType i{0}; (result and (i < m_elementCount)); ++i)
result = not AreEqual(element, m_elements[i]);
return result;
}

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Set>;
using size_type = SizeType;
using value_type = T;

constexpr Set() noexcept : m_elementCount(0), m_elementDefault(T{}) {
}

constexpr explicit Set(const std::initializer_list<const T> elements) noexcept
    : m_elementCount(0), m_elementDefault(T{}) {

for(const auto& element : elements) {
if(m_elementCount == MaximumCount())
break;
if(IsUniqueElement(element))
m_elements[m_elementCount++] = element;
}
}

constexpr Set(const Set& other) = default;
constexpr Set(Set&& other) = default;

constexpr const T* begin() const noexcept {
return m_elements;
}

constexpr const T* end() const noexcept {
return m_elements + m_elementCount;
}

constexpr T operator[](const SizeType index) const noexcept override {
return (index < m_elementCount) ? m_elements[index] : m_elementDefault;
}

constexpr T operator()(const SizeType index) const noexcept {
return this->operator[](index);
}

constexpr Set& operator=(const Set& other) noexcept {
if(this != &other) {
m_elementCount = other.m_elementCount;
for(SizeType i{0}; i < m_elementCount; ++i) {
m_elements[i] = other.m_elements[i];
}
}
return *this;
}

constexpr Set& operator=(Set&& other) noexcept {
if(this != &other) {
m_elementCount = other.m_elementCount;
for(SizeType i{0}; i < m_elementCount; ++i) {
m_elements[i] = std::move(other.m_elements[i]);
}
other.m_elementCount = 0;
}
return *this;
}

constexpr bool operator==(const auto& other) const noexcept {
return AreEqual(*this, other);
}

constexpr bool operator!=(const auto& other) const noexcept {
return not(*this == other);
}

[[nodiscard]] constexpr SizeType Count() const noexcept override {
return m_elementCount;
}

constexpr bool ContainsBy(const auto& f, const T& element) const noexcept {
return not IsUniqueElementBy(f, element);
}

constexpr bool Contains(const T& element) const noexcept {
return not IsUniqueElement(element);
}

constexpr int DefaultElement() const noexcept {
return m_elementDefault;
}

constexpr bool ElementAtIndexIsEqualToElement(const SizeType index, const T& element) const noexcept override {
return (index < m_elementCount) and Contains(element);
}

static constexpr SizeType MaximumCount() noexcept {
return maximumElements;
}

constexpr void MInsert(const T& value) {
if((m_elementCount < maximumElements) and IsUniqueElement(value))
m_elements[m_elementCount++] = value;
}
};

template <typename... Args>
Set(Args...) -> Set<std::common_type_t<Args...>, sizeof...(Args)>;

} // namespace cljonic

#include <cstring>
#include <initializer_list>
#include <type_traits>
#include <utility>

namespace cljonic {

template <SizeType MaxElements>
class String : public IndexInterface<char> {
using Iterator = CollectionIterator<String>;

static constexpr SizeType maximumElements{MaximumElements(MaxElements)};

static_assert(maximumElements == MaxElements,
              "Attempt to create a String bigger than CljonicCollectionMaximumElementCount");

SizeType m_elementCount;
const char m_elementDefault;
char m_elements[maximumElements + 1]{};

constexpr auto ValueAtIndex(const SizeType index) const noexcept {
return (index < m_elementCount) ? m_elements[index] : m_elementDefault;
}

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::String>;
using size_type = SizeType;
using value_type = char;

constexpr String() noexcept : m_elementCount(0), m_elementDefault('\0') {
m_elements[0] = '\0';
}

constexpr explicit String(const std::initializer_list<const char> elements) noexcept
    : m_elementCount(0), m_elementDefault('\0') {
for(const auto& element : elements) {
if(m_elementCount == MaximumCount())
break;
m_elements[m_elementCount++] = element;
}
m_elements[m_elementCount] = '\0';
}

constexpr explicit String(const char* c_str) noexcept : m_elementCount(0), m_elementDefault('\0') {
while((m_elementCount < MaximumCount()) and ('\0' != c_str[m_elementCount])) {
m_elements[m_elementCount] = c_str[m_elementCount];
m_elementCount += 1;
}
m_elements[m_elementCount] = '\0';
}

constexpr String(const String& other) = default;
constexpr String(String&& other) = default;

[[nodiscard]] constexpr Iterator begin() const noexcept {
return Iterator{*this, 0};
}

[[nodiscard]] constexpr Iterator end() const noexcept {
return Iterator{*this, m_elementCount};
}

constexpr char operator[](const SizeType index) const noexcept override {
return ValueAtIndex(index);
}

constexpr char operator()(const SizeType index) const noexcept {
return this->operator[](index);
}

constexpr String& operator=(const String& other) noexcept {
if(this != &other) {
m_elementCount = other.m_elementCount;
for(SizeType i{0}; i <= m_elementCount; ++i)
m_elements[i] = other.m_elements[i];
}
return *this;
}

constexpr String& operator=(String&& other) noexcept {
if(this != &other) {
m_elementCount = other.m_elementCount;
std::move(other.m_elements, other.m_elements + other.m_elementCount + 1, m_elements);
other.m_elementCount = 0;
other.m_elements[0] = '\0';
}
return *this;
}

constexpr bool operator==(const auto& other) const noexcept {
return AreEqual(*this, other);
}

constexpr bool operator!=(const auto& other) const noexcept {
return not(*this == other);
}

[[nodiscard]] constexpr SizeType Count() const noexcept override {
return m_elementCount;
}

constexpr char DefaultElement() const noexcept {
return m_elementDefault;
}

constexpr bool ElementAtIndexIsEqualToElement(const SizeType index, const char& element) const noexcept override {
return (index < m_elementCount) and AreEqual(ValueAtIndex(index), element);
}

static constexpr SizeType MaximumCount() noexcept {
return maximumElements;
}
};

template <SizeType N>
String(const char (&)[N]) -> String<N - 1>;

template <typename... Args>
String(Args...) -> String<sizeof...(Args)>;

} // namespace cljonic

namespace cljonic {

namespace core {
}

}

#include <utility>

namespace cljonic {

namespace core {

template <typename F1, typename F2, typename... Args>
concept ComposeIsCallableWith = requires(F1 f1, F2 f2, Args&&... args) {
{ f1(f2(std::forward<Args>(args)...)) };
};

template <typename F1, typename F2>
constexpr auto Compose(F1&& f1, F2&& f2) noexcept {
return [f1 = std::forward<F1>(f1), f2 = std::forward<F2>(f2)]<typename... T>(T&&... args) {
static_assert(ComposeIsCallableWith<F1, F2, T...>,
              "Each Compose argument must be callable with one argument of the return type of the argument to "
              "its right. Was the Compose result function called with the correct number of arguments?");

return f1(f2(std::forward<T>(args)...));
};
}
template <typename F1, typename F2, typename... Fs>
constexpr auto Compose(F1&& f1, F2&& f2, Fs&&... fs) noexcept {
return Compose(std::forward<F1>(f1), Compose(std::forward<F2>(f2), std::forward<Fs>(fs)...));
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C, typename... Cs>
constexpr auto Concat(const C& c, const Cs&... cs) noexcept {

static_assert(AllCljonicCollections<C, Cs...>, "All Concat parameters must be cljonic collections");

static_assert(AllConvertibleValueTypes<C, Cs...>,
              "All Concat cljonic collection value types must be interconvertible");

using ResultType = FindCommonValueType<C, Cs...>;

constexpr auto count{SumOfCljonicCollectionMaximumCounts<C, Cs...>()};
auto result{Array<ResultType, count>{}};
const auto MAppendCollectionOnResult = [&](const auto& c) {
for(const auto& v : c)
result.MAppend(static_cast<ResultType>(v));
};
(MAppendCollectionOnResult(c), ..., MAppendCollectionOnResult(cs));
return result;
}

constexpr auto Concat() noexcept {
return Array<int, 0>{};
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C, typename... Es>
constexpr auto Conj(const C& c, const Es&... es) noexcept {

static_assert(IsCljonicCollection<C>, "First Conj parameter must be a cljonic collection");

static_assert(AllConvertibleTypes<typename C::value_type, Es...>,
              "Second through last Conj parameters must be convertible to cljonic collection value type");

using ResultType = typename C::value_type;
constexpr auto count{C::MaximumCount() + sizeof...(Es)};
auto result{Array<ResultType, count>{}};
const auto MAppendElementOntoResult = [&](const auto& e) { result.MAppend(e); };
for(const ResultType& v : c)
MAppendElementOntoResult(v);
(MAppendElementOntoResult(es), ...);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Count(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Count's parameter must be a cljonic collection");

return c.Count();
}

}

} // namespace cljonic::core

#include <utility>

namespace cljonic {

namespace core {

template <typename C>
class CycleCollection {
using ElementType = typename C::value_type;

C m_collection;

[[nodiscard]] constexpr SizeType IndexToElementIndex(const SizeType index) const noexcept {
return (0 == m_collection.Count()) ? 0 : (index % m_collection.Count());
}

class CycleIterator {
const CycleCollection& m_cycle;
SizeType m_index;

public:
constexpr CycleIterator(const CycleCollection& cycle, const SizeType index) noexcept
    : m_cycle(cycle), m_index(index) {
}

constexpr auto operator*() const noexcept -> decltype(m_cycle[m_index]) {
return m_cycle[m_cycle.IndexToElementIndex(m_index)];
}

constexpr CycleIterator& operator++() noexcept {
++m_index;
return *this;
}

constexpr bool operator!=(const CycleIterator& other) const noexcept {
return m_index != other.m_index;
}

constexpr CycleIterator& operator+=(const int value) noexcept {
m_index += value;
return *this;
}

constexpr CycleIterator operator+(const int value) const noexcept {
CycleIterator temp = *this;
temp += value;
return temp;
}
};

public:
using cljonic_collection_type = std::integral_constant<CljonicCollectionType, CljonicCollectionType::Cycle>;
using size_type = SizeType;
using value_type = ElementType;

constexpr explicit CycleCollection(const C& collection) : m_collection(collection) {
}

constexpr explicit CycleCollection(C&& collection) : m_collection(std::move(collection)) {
}

constexpr CycleCollection(const CycleCollection& other) = default;
constexpr CycleCollection(CycleCollection&& other) = default;

[[nodiscard]] constexpr CycleIterator begin() const noexcept {
return CycleIterator(*this, 0);
}

[[nodiscard]] constexpr CycleIterator end() const noexcept {
return CycleIterator(*this, MaximumCount());
}

[[nodiscard]] constexpr ElementType operator[](const SizeType index) const noexcept {
return m_collection[IndexToElementIndex(index)];
}

[[nodiscard]] constexpr SizeType Count() const noexcept {
return MaximumCount();
}

[[nodiscard]] constexpr ElementType& DefaultElement() const noexcept {
return m_collection.DefaultElement();
}

[[nodiscard]] constexpr SizeType MaximumCount() const noexcept {
return (0 == m_collection.Count()) ? 0 : CljonicCollectionMaximumElementCount;
}
};
template <typename C>
constexpr auto Cycle(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Cycle's parameter must be a cljonic collection");

return CycleCollection{c};
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Dedupe(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Dedupe's parameter must be a cljonic collection");

static_assert((not std::floating_point<typename C::value_type>),
              "Dedupe should not compare cljonic floating point collection value types for equality. Consider "
              "using DedupeBy to override this default.");

return DedupeBy([](const auto& a, const auto& b) { return AreEqual(a, b); }, c);
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto DedupeBy(F&& f, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "DedupeBy's second parameter must be a cljonic collection");

static_assert(IsBinaryPredicate<std::decay_t<F>, typename C::value_type, typename C::value_type>,
              "DedupeBy's function is not a valid binary predicate for the collection value type");

using ValueType = typename C::value_type;

constexpr auto AdvanceIteratorToNextElementNotEqualToCurrentElement = [](const F& fn, auto& it, const auto& end) {
auto currentElement{*it};
++it;
while((it != end) and fn(*it, currentElement))
++it;
};

auto result{Array<ValueType, c.MaximumCount()>{}};
auto cBegin{c.begin()};
auto cEnd{c.end()};
for(auto it{cBegin}; it != cEnd;) {
result.MAppend(*it);
AdvanceIteratorToNextElementNotEqualToCurrentElement(f, it, cEnd);
}
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto DefaultElement(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "DefaultElement's parameter must be a cljonic collection");

return c.DefaultElement();
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Drop(const SizeType count, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Drop's second parameter must be a cljonic collection");

using ResultType = typename C::value_type;
auto dropCount{MinArgument(count, c.Count())};
auto cBegin{c.begin() + dropCount};
auto cEnd{c.end()};
auto result{Array<ResultType, c.MaximumCount()>{}};
for(auto it{cBegin}; it != cEnd; ++it)
result.MAppend(static_cast<ResultType>(*it));
return result;
}

template <SizeType N, typename C>
constexpr auto Drop(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Drop's parameter must be a cljonic collection");

using ResultType = typename C::value_type;
constexpr auto dropCount{MinArgument(N, c.Count())};
auto cBegin{c.begin() + dropCount};
auto cEnd{c.end()};
auto result{Array<ResultType, (c.MaximumCount() - dropCount)>{}};
for(auto it{cBegin}; it != cEnd; ++it)
result.MAppend(static_cast<ResultType>(*it));
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto DropLast(const SizeType count, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "DropLast's second parameter must be a cljonic collection");

using ResultType = typename C::value_type;
auto result{Array<ResultType, c.MaximumCount()>{}};
auto cBegin(c.begin());
auto cEnd{(count > c.Count()) ? cBegin : (c.end() - count)};
for(auto it{cBegin}; it != cEnd; ++it)
result.MAppend(static_cast<ResultType>(*it));
return result;
}

template <SizeType N, typename C>
constexpr auto DropLast(const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "DropLast's parameter must be a cljonic collection");

using ResultType = typename C::value_type;
constexpr auto resultMaximumCount{(N > c.MaximumCount()) ? 0 : (c.MaximumCount() - N)};
auto result{Array<ResultType, resultMaximumCount>{}};
auto cBegin(c.begin());
auto cEnd{(N > c.Count()) ? cBegin : (c.end() - N)};
for(auto it{cBegin}; it != cEnd; ++it)
result.MAppend(static_cast<ResultType>(*it));
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto DropWhile(F&& f, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "DropWhile's second parameter must be a cljonic collection");

static_assert(IsUnaryPredicate<std::decay_t<F>, typename C::value_type>,
              "DropWhile's function is not a valid unary predicate for the collection value type");

auto result{Array<typename C::value_type, c.MaximumCount()>{}};
auto conjElement(false);
for(const auto& element : c)
if(conjElement |= (not f(element)))
result.MAppend(element);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename T, typename... Ts>
constexpr auto Equal(const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) == 0) {
if constexpr(IsCljonicCollection<T>)
static_assert((not std::floating_point<typename T::value_type>),
              "Equal should not compare cljonic floating point collection value types for equality. "
              "Consider using EqualBy to override this default.");
else
static_assert((not std::floating_point<T>),
              "Equal should not compare floating point types for equality. Consider using EqualBy to "
              "override this default.");
return true;
} else if constexpr(AllCljonicCollections<T, Ts...>) {
static_assert(not AnyFloatingPointValueTypes<T, Ts...>,
              "Equal should not compare cljonic floating point collection value types for equality. Consider "
              "using EqualBy to override this default.");

static_assert(AllSameCljonicCollectionType<T, Ts...> or AllCljonicArrayRangeOrRepeat<T, Ts...>,
              "Equal cljonic collection types are not all the same, or all Array, Range or Repeat types");

return (AreEqual(t, ts) and ...);
} else {
static_assert(not AnyFloatingPointTypes<T, Ts...>,
              "Equal should not compare floating point types for equality. Consider using EqualBy to override "
              "this default.");

static_assert(AllEqualityComparableTypes<T, Ts...>, "Not all Equal types are equality comparable");

return (AreEqual(t, ts) and ...);
}
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename T, typename... Ts>
constexpr auto EqualBy(F&& f, const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) <= 0) {
return true;
} else if constexpr(AllCljonicCollections<T, Ts...>) {
static_assert(AllSameCljonicCollectionType<T, Ts...> or AllCljonicArrayRangeOrRepeat<T, Ts...>,
              "EqualBy cljonic collection types are not all the same, or all Array, Range or Repeat types");

static_assert(IsBinaryPredicateForAllCljonicCollections<std::decay_t<F>, T, Ts...>,
              "EqualBy function is not a valid binary predicate for all cljonic collection value types");

return (AreEqualBy(f, t, ts) and ...);
} else {
static_assert(AllEqualityComparableTypes<T, Ts...>, "Not all EqualBy types are equality comparable");

static_assert(IsBinaryPredicateForAll<F, T, Ts...>,
              "EqualBy function is not a valid binary predicate for all parameters");

return (AreEqualBy(f, t, ts) and ...);
}
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto Every(F&& f, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Every's second parameter must be a cljonic collection");

static_assert(IsUnaryPredicate<std::decay_t<F>, typename C::value_type>,
              "Every's function is not a valid unary predicate for the collection value type");

auto result{true};
for(auto it{c.begin()}; (result and (it != c.end())); ++it)
result = f(*it);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto Filter(F&& f, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Filter's second parameter must be a cljonic collection");

static_assert(IsUnaryPredicate<std::decay_t<F>, typename C::value_type>,
              "Filter's function is not a valid unary predicate for the collection value type");

auto result{Array<typename C::value_type, c.MaximumCount()>{}};
for(const auto& element : c)
if(f(element))
result.MAppend(element);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto First(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "First's parameter must be a cljonic collection");

return (c.Count() > 0) ? *c.begin() : c.DefaultElement();
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename T, typename... Ts>
constexpr auto Identical(const T& t, const Ts&... ts) noexcept {
if constexpr(sizeof...(Ts) <= 0) {
return true;
} else {
auto SameIdentity = [&](const auto& t1, const auto& t2) { return Identity(t1) == Identity(t2); };
return (SameIdentity(t, ts) and ...);
}
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename T>
constexpr void* Identity(const T& t) noexcept {
return (void*)&t;
}

}

} // namespace cljonic::core

#include <limits>

namespace cljonic {

namespace core {
template <typename T>
constexpr auto Inc(const T t) noexcept {
static_assert(IsArithmetic<T>, "Inc's parameter must be an arithmetic type");

return (std::numeric_limits<T>::max() == t) ? t : (t + static_cast<T>(1));
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C, typename T>
constexpr auto IndexOf(const C& c, const T& t) noexcept {

static_assert(IsCljonicCollection<C>, "IndexOf's first parameter must be a cljonic collection");

static_assert((not std::floating_point<typename C::value_type>) and (not std::floating_point<T>),
              "IndexOf should not compare floating point types for equality. Consider using IndexOfBy to override "
              "this default.");

static_assert(std::convertible_to<T, typename C::value_type>,
              "IndexOf's second parameter must be convertible to the collection value type");

auto result{CljonicInvalidIndex};
auto it{c.begin()};
auto cEnd{c.end()};
for(SizeType i{0}; ((CljonicInvalidIndex == result) and (it != cEnd)); ++it, ++i)
if(AreEqual(*it, t))
result = i;
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C, typename T>
constexpr auto IndexOfBy(F&& f, const C& c, const T& t) noexcept {

static_assert(IsCljonicCollection<C>, "IndexOfBy's second parameter must be a cljonic collection");

static_assert(IsBinaryPredicate<std::decay_t<F>, typename C::value_type, typename C::value_type>,
              "IndexOfBy's function is not a valid binary predicate for the collection value type");

static_assert(std::convertible_to<T, typename C::value_type>,
              "IndexOfBy's third parameter must be convertible to the collection value type");

auto result{CljonicInvalidIndex};
auto it{c.begin()};
auto cEnd{c.end()};
for(SizeType i{0}; ((CljonicInvalidIndex == result) and (it != cEnd)); ++it, ++i)
if(f(*it, t))
result = i;
return result;
}

}

} // namespace cljonic::core

#include <concepts>
#include <tuple>

namespace cljonic {

namespace core {
template <typename C, typename... Cs>
constexpr auto Interleave(const C& c, const Cs&... cs) noexcept {

static_assert(AllCljonicCollections<C, Cs...>, "Interleave's parameters must all be cljonic collections");

static_assert(AllConvertibleValueTypes<C, Cs...>,
              "All Interleave cljonic collection value types must be interconvertible");

using ResultType = FindCommonValueType<C, Cs...>;
constexpr auto minimumCollectionMaximumCount{MinimumOfCljonicCollectionMaximumCounts<C, Cs...>()};
constexpr auto collectionsCount{sizeof...(Cs) + 1};
constexpr auto resultCount{minimumCollectionMaximumCount * collectionsCount};
auto result{Array<ResultType, resultCount>{}};
auto itrs{std::make_tuple(c.begin(), cs.begin()...)};
for(SizeType i{0}; i < minimumCollectionMaximumCount; ++i)
std::apply([&](auto&... itrs) { (result.MAppend(*itrs++), ...); }, itrs);
return result;
}

constexpr auto Interleave() noexcept {
return Array<int, 0>{};
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename T, typename C>
constexpr auto Interpose(const T& t, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "Interpose's second parameter must be a cljonic collection");

static_assert(std::convertible_to<T, typename C::value_type>,
              "Interpose's first parameter must be convertible to cljonic collection value type");

using ResultType = typename C::value_type;
constexpr auto collectionMaximumCount{c.MaximumCount()};
constexpr auto resultMaximumCount{(2 * collectionMaximumCount) - 1};
auto cItr{c.begin()};
auto interposeValue{static_cast<ResultType>(t)};
auto result{Array<ResultType, resultMaximumCount>{}};
for(SizeType i{0}; i < collectionMaximumCount; ++i) {
result.MAppend(*cItr++);
result.MAppend(interposeValue);
}
return result;
}

constexpr auto Interpose() noexcept {
return Array<int, 0>{};
}

}

} // namespace cljonic::core

#include <array>

namespace cljonic {

namespace core {
template <typename T, typename... Ts>
constexpr bool IsDistinct(const T& t, const Ts&... ts) noexcept {

if constexpr(0 == sizeof...(Ts)) {

if constexpr((not IsCljonicCollection<T>) or IsCljonicSet<T>) {

return true;
} else {

static_assert(not std::floating_point<typename T::value_type>,
              "IsDistinct should not compare cljonic floating point collection value types for equality. "
              "Consider using IsDistinctBy to override this default.");

auto tSet{Set<typename T::value_type, t.MaximumCount()>{}};
auto tSetCount{tSet.Count()};
for(const auto& v : t) {
tSet.MInsert(v);
if(tSet.Count() == tSetCount)
return false;
tSetCount = tSet.Count();
}
return true;
}
} else {
static_assert(not AnyFloatingPointTypes<T, Ts...>,
              "IsDistinct should not compare floating point types for equality. Consider using IsDistinctBy to "
              "override this default.");

if constexpr(AllCljonicCollections<T, Ts...>) {
static_assert(AllEqualityComparableValueTypes<T, Ts...>,
              "Not all IsDistinct value types are equality comparable");
} else {
static_assert(AllEqualityComparableTypes<T, Ts...>, "Not all IsDistinct types are equality comparable");
}

auto tPtrs{std::array<const T*, sizeof...(Ts) + 1>{&t, static_cast<const T*>(&ts)...}};
auto tSet{Set<T, (sizeof...(ts) + 1)>{}};
auto tSetCount{tSet.Count()};
for(const auto& tPtr : tPtrs) {
tSet.MInsert(*tPtr);
if(tSet.Count() == tSetCount)
return false;
tSetCount = tSet.Count();
}
return true;
}
}

}

} // namespace cljonic::core

#include <array>

namespace cljonic {

namespace core {
template <typename F, typename T, typename... Ts>
constexpr auto IsDistinctBy(F&& f, const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) == 0) {
return true;
} else {
if constexpr(AllCljonicCollections<T, Ts...>) {
static_assert(
    AllSameCljonicCollectionType<T, Ts...> or AllCljonicArrayRangeOrRepeat<T, Ts...>,
    "IsDistinctBy cljonic collection types are not all the same, or all Array, Range or Repeat types");

static_assert(
    IsBinaryPredicateForAllCljonicCollections<std::decay_t<F>, T, Ts...>,
    "IsDistinctBy function is not a valid binary predicate for all cljonic collection value types");

constexpr auto IndexInterfacesEqualBy = [](auto&& f, const auto& t, const auto& u) noexcept {
if(&t == &u)
return true;
if(t.Count() != u.Count())
return false;
if constexpr(IsCljonicSet<T>) {
constexpr auto ContainsBy = [](auto&& f, const auto& setIndex, const auto& element) noexcept {
auto result{false};
for(SizeType i{0}; ((not result) and (i < setIndex.Count())); ++i)
result = f(setIndex[i], element);
return result;
};
for(SizeType i{0}; i < t.Count(); ++i)
if(not ContainsBy(f, t, u[i]))
return false;
return true;
} else {
for(SizeType i{0}; i < t.Count(); ++i)
if(not f(t[i], u[i]))
return false;
return true;
}
};
using I = const IndexInterface<typename T::value_type>*;
constexpr auto n{sizeof...(Ts) + 1};
const auto i{std::array<I, n>{static_cast<I>(&t), static_cast<I>(&ts)...}};
for(SizeType j{0}; j < n; ++j)
for(SizeType k{j + 1}; k < n; ++k)
if(IndexInterfacesEqualBy(std::forward<F>(f), *i[j], *i[k]))
return false;
return true;
} else {
static_assert(IsBinaryPredicateForAll<std::decay_t<F>, T, Ts...>,
              "IsDistinctBy function is not a valid binary predicate for all parameters");

return ((f(t, ts) == false) and ...) and IsDistinctBy(std::forward<F>(f), ts...);
}
}
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto IsEmpty(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "IsEmpty's parameter must be a cljonic collection");

return 0 == c.Count();
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto IsFull(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "IsFull's parameter must be a cljonic collection");

return c.Count() == c.MaximumCount();
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename T>
constexpr auto Iterate(F&& f, const T& t) noexcept {
static_assert(IsUnaryFunction<F, T>, "Iterate's first parameter is not a unary function of its second parameter");

return Iterator{std::forward<F>(f), t};
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Last(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Last's parameter must be a cljonic collection");

return *(c.begin() + (c.Count() - 1));
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C, typename T>
constexpr auto LastIndexOf(const C& c, const T& t) noexcept {

static_assert(IsCljonicCollection<C>, "LastIndexOf's first parameter must be a cljonic collection");

static_assert(std::equality_comparable_with<typename C::value_type, T>,
              "LastIndexOf's second parameter is not equality comparable with the cljonic collection values");

static_assert(not std::floating_point<typename C::value_type>,
              "LastIndexOf should not compare floating point types for equality. Consider using LastIndexOfBy to "
              "override this default.");

static_assert(not std::floating_point<T>,
              "LastIndexOf should not compare floating point types for equality. Consider using LastIndexOfBy to "
              "override this default.");

if constexpr(IsCljonicIterator<C>) {
auto result{CljonicInvalidIndex};
auto cBegin{c.begin()};
auto cEnd{c.end()};
auto index{0};
for(auto& it{cBegin}; it != cEnd; ++index, ++it)
if(AreEqual(*it, t))
result = index;
return result;
} else {
auto result{CljonicInvalidIndex};
auto cIt{c.end() - 1};
for(SizeType nextIndex{c.Count()}; ((CljonicInvalidIndex == result) and (nextIndex > 0)); --cIt, --nextIndex)
if(AreEqual(*cIt, t))
result = nextIndex - 1;
return result;
}
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C, typename T>
constexpr auto LastIndexOfBy(F&& f, const C& c, const T& t) noexcept {

static_assert(IsCljonicCollection<C>, "LastIndexOfBy's second parameter must be a cljonic collection");

static_assert(std::equality_comparable_with<typename C::value_type, T>,
              "LastIndexOfBy's third parameter is not equality comparable with the cljonic collection values");

static_assert(IsBinaryPredicate<F, typename C::value_type, T>,
              "LastIndexOfBy's first parameter is not a valid binary predicate for the collection value type");

if constexpr(IsCljonicIterator<C>) {
auto result{CljonicInvalidIndex};
auto cBegin{c.begin()};
auto cEnd{c.end()};
auto index{0};
for(auto& it{cBegin}; it != cEnd; ++index, ++it)
if(f(*it, t))
result = index;
return result;
} else {
auto result{CljonicInvalidIndex};
auto cIt{c.end() - 1};
for(SizeType nextIndex{c.Count()}; ((CljonicInvalidIndex == result) and (nextIndex > 0)); --cIt, --nextIndex)
if(f(*cIt, t))
result = nextIndex - 1;
return result;
}
}

}

} // namespace cljonic::core

#include <concepts>

namespace cljonic {

namespace core {
template <typename F, typename C, typename... Cs>
constexpr auto Map(F&& f, const C& c, const Cs&... cs) noexcept {

static_assert(AllCljonicCollections<C, Cs...>, "Map's second through last parameters must be cljonic collections");

static_assert(std::invocable<F, typename C::value_type, typename Cs::value_type...>,
              "Map's function cannot be called with values from the specified cljonic collections");

using ResultType = decltype(f(std::declval<typename C::value_type>(), std::declval<typename Cs::value_type>()...));

constexpr auto minimumCollectionMaximumCount{MinimumOfCljonicCollectionMaximumCounts<C, Cs...>()};
auto result{Array<ResultType, minimumCollectionMaximumCount>{}};
auto itrs{std::make_tuple(c.begin(), cs.begin()...)};
auto minimumCount{MinArgument(c.Count(), cs.Count()...)};
for(SizeType i{0}; i < minimumCount; ++i)
result.MAppend(std::apply([&](auto&... iter) { return f(*iter++...); }, itrs));
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename T, typename... Ts>
constexpr auto Max(const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) == 0) {
static_assert(IsCljonicCollection<T>, "Max's parameter must be a cljonic collection");

auto result{t.DefaultElement()};
if(t.Count() > 0) {
auto tBegin{t.begin()};
auto tEnd{t.end()};
result = *tBegin++;
for(auto it{tBegin}; it != tEnd; ++it)
if(result < *it)
result = *it;
}
return result;
} else {
static_assert(AllNotCljonicCollections<T, Ts...>, "None of Max's parameters can be cljonic collections");

auto result{t};
(..., (void)((result < ts) ? result = ts : result));
return result;
}
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename T, typename... Ts>
constexpr auto MaxBy(F&& f, const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) == 0) {
static_assert(IsCljonicCollection<T>, "MaxBy's second parameter must be a cljonic collection");

static_assert(IsBinaryPredicate<F, typename T::value_type, typename T::value_type>,
              "MaxBy function is not a valid binary predicate for the collection value type");

auto result{t.DefaultElement()};
if(t.Count() > 0) {
auto tBegin{t.begin()};
auto tEnd{t.end()};
result = *tBegin++;
for(auto it{tBegin}; it != tEnd; ++it)
if(f(result, *it))
result = *it;
}
return result;
} else {
static_assert(AllNotCljonicCollections<T, Ts...>,
              "None of MaxBy's second through last parameters can be cljonic collections");

static_assert(IsBinaryPredicate<F, T, T>,
              "MaxBy function is not a valid binary predicate for the collection value type");

auto result{t};
(..., (void)(f(result, ts) ? result = ts : result));
return result;
}
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename T, typename... Ts>
constexpr auto Min(const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) == 0) {
static_assert(IsCljonicCollection<T>, "Min's parameter must be a cljonic collection");

auto result{t.DefaultElement()};
if(t.Count() > 0) {
auto tBegin{t.begin()};
auto tEnd{t.end()};
result = *tBegin++;
for(auto it{tBegin}; it != tEnd; ++it)
if(*it < result)
result = *it;
}
return result;
} else {
static_assert(AllNotCljonicCollections<T, Ts...>, "None of Min's parameters can be cljonic collections");

auto result{t};
(..., (void)((ts < result) ? result = ts : result));
return result;
}
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename T, typename... Ts>
constexpr auto MinBy(F&& f, const T& t, const Ts&... ts) noexcept {

if constexpr(sizeof...(Ts) == 0) {
static_assert(IsCljonicCollection<T>, "MinBy's second parameter must be a cljonic collection");

static_assert(IsBinaryPredicate<F, typename T::value_type, typename T::value_type>,
              "MinBy function is not a valid binary predicate for the collection value type");

auto result{t.DefaultElement()};
if(t.Count() > 0) {

auto tBegin{t.begin()};
auto tEnd{t.end()};
result = *tBegin++;
for(auto it{tBegin}; it != tEnd; ++it)
if(not f(result, *it))
result = *it;
}
return result;
} else {
static_assert(AllNotCljonicCollections<T, Ts...>,
              "None of MinBy's second through last parameters can be cljonic collections");

static_assert(IsBinaryPredicate<F, T, T>,
              "MinBy function is not a valid binary predicate for the collection value type");

auto result{t};
(..., (void)((not f(result, ts)) ? result = ts : result));
return result;
}
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto NotAny(F&& f, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "NotAny's second parameter must be a cljonic collection");

static_assert(IsUnaryPredicate<std::decay_t<F>, typename C::value_type>,
              "NotAny's function is not a valid unary predicate for the collection value type");

return (c.Count() == 0) or (not Some(std::forward<F>(f), c));
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto NotEvery(F&& f, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "NotEvery's second parameter must be a cljonic collection");

static_assert(IsUnaryPredicate<std::decay_t<F>, typename C::value_type>,
              "NotEvery's function is not a valid unary predicate for the collection value type");

return (c.Count() != 0) and (not Every(std::forward<F>(f), c));
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C, typename T>
constexpr auto Nth(const C& c, const SizeType index, const T& t) noexcept {
static_assert(IsCljonicCollection<C> and (not IsCljonicSet<C>),
              "Nth's first parameter must be a cljonic collection other than a Set");

static_assert(std::same_as<typename C::value_type, T>,
              "Nth's third parameter must have the same type as the values in the first parameter");

return (index < c.Count()) ? *(c.begin() + index) : t;
}

template <typename C>
constexpr auto Nth(const C& c, const SizeType index) noexcept {
static_assert(IsCljonicCollection<C> and (not IsCljonicSet<C>),
              "Nth's first parameter must be a cljonic collection other than a Set");

return Nth(c, index, c.DefaultElement());
}

}

} // namespace cljonic::core

#include <utility>

namespace cljonic {

namespace core {
template <typename F, typename... Args>
constexpr auto Partial(F&& f, Args&&... args) noexcept {
return [f = std::forward<F>(f), ... args = std::forward<Args>(args)](auto&&... rest) {
static_assert(std::regular_invocable<F, Args..., decltype(rest)...>,
              "Partial's function cannot be called with the specified arguments");

return f(args..., std::forward<decltype(rest)>(rest)...);
};
}

}

} // namespace cljonic::core

#include <numeric>
#include <tuple>

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto Reduce(F&& f, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Reduce's second parameter must be a cljonic collection");

static_assert(std::regular_invocable<F, typename C::value_type, typename C::value_type>,
              "Reduce's function cannot be called with two parameters of the collection value type");

using ResultType = std::invoke_result_t<F, typename C::value_type, typename C::value_type>;
static_assert(
    std::regular_invocable<F, ResultType, typename C::value_type>,
    "Reduce's function cannot be called with parameters of function result type, and collection value type");

return (0 == c.Count()) ? c.DefaultElement()
                        : std::accumulate((c.begin() + 1), c.end(), *c.begin(), std::forward<F>(f));
}

template <typename F, typename T, typename C>
constexpr auto Reduce(F&& f, const T& t, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Reduce's third parameter must be a cljonic collection");

static_assert(
    std::regular_invocable<F, T, typename C::value_type>,
    "Reduce's function cannot be called with parameters of initial value type, and collection value type");

using ResultType = std::invoke_result_t<F, T, typename C::value_type>;
static_assert(
    std::regular_invocable<F, ResultType, typename C::value_type>,
    "Reduce's function cannot be called with parameters of function result type, and collection value type");

return (0 == c.Count()) ? t : std::accumulate(c.begin(), c.end(), t, std::forward<F>(f));
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto Remove(F&& f, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Remove's second parameter must be a cljonic collection");

static_assert(IsUnaryPredicate<std::decay_t<F>, typename C::value_type>,
              "Remove's function is not a valid unary predicate for the collection value type");

auto result{Array<typename C::value_type, c.MaximumCount()>{}};
for(const auto& element : c)
if(not f(element))
result.MAppend(element);
return result;
}

}

} // namespace cljonic::core

#include <concepts>

namespace cljonic {

namespace core {
template <typename C1, typename C2>
constexpr auto Replace(const C1& c1, const C2& c2) noexcept {

static_assert(IsCljonicCollection<C1>, "Replace's first parameter must be a cljonic collection");

static_assert(IsCljonicCollection<C2>, "Replace's second parameter must be a cljonic collection");

static_assert(IsConvertibleToIntegral<typename C2::value_type>,
              "Replace's second parameter value type must be convertible to an integral");

static_assert(std::convertible_to<typename C2::value_type, typename C1::value_type>,
              "Replace's second parameter value type must be convertible to the first parameter value type");

auto result{Array<typename C1::value_type, c2.MaximumCount()>{}};
for(const auto& v2 : c2)
result.MAppend(((v2 >= 0) and (static_cast<SizeType>(v2) < c1.Count())) ? *(c1.begin() + v2) : v2);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Reverse(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Reverse's parameter must be a cljonic collection");

auto result{Array<typename C::value_type, C::MaximumCount()>{}};
for(const auto& v : c)
result.MAppend(v);
result.MReverse();
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Second(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Second's parameter must be a cljonic collection");

return (c.Count() > 1) ? *(c.begin() + 1) : c.DefaultElement();
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Seq(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Seq's parameter must be a cljonic collection");

using ResultType = typename C::value_type;
auto result{Array<ResultType, C::MaximumCount()>{}};
for(const ResultType& v : c)
result.MAppend(v);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Size(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Size's parameter must be a cljonic collection");

return c.MaximumCount();
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto Some(F&& f, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "Some's second parameter must be a cljonic collection");

static_assert(IsUnaryPredicate<std::decay_t<F>, typename C::value_type>,
              "Some's function is not a valid unary predicate for the collection value type");

for(const auto& i : c)
if(f(i))
return true;
return false;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Sort(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Sort's parameter must be a cljonic collection");

using ResultType = typename C::value_type;
auto result{Array<ResultType, C::MaximumCount()>{}};
for(const ResultType& v : c)
result.MAppend(v);
result.MSort();
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto SortBy(F&& f, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "SortBy's second parameter must be a cljonic collection");

static_assert(IsBinaryPredicate<std::decay_t<F>, typename C::value_type, typename C::value_type>,
              "SortBy's function is not a valid binary predicate for the collection value type");

using ResultType = typename C::value_type;
auto result{Array<ResultType, C::MaximumCount()>{}};
for(const ResultType& v : c)
result.MAppend(v);
result.MSortBy(std::forward<F>(f));
return result;
}

}

} // namespace cljonic::core

#include <tuple>

namespace cljonic {

namespace core {
template <typename C>
constexpr auto SplitAt(const SizeType count, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "SplitAt's second parameter must be a cljonic collection");

using ResultType = typename C::value_type;
using ArrayType = Array<ResultType, C::MaximumCount()>;
auto result{Array{ArrayType{}, ArrayType{}}};
auto lhs{result.MPtr(0)};
auto rhs{result.MPtr(1)};
auto i{SizeType{0}};
for(const ResultType& v : c)
if(i++ < count)
lhs->MAppend(v);
else
rhs->MAppend(v);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto SplitWith(F&& f, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "SplitWith's second parameter must be a cljonic collection");

static_assert(IsUnaryPredicate<std::decay_t<F>, typename C::value_type>,
              "SplitWith's function is not a valid unary predicate for the collection value type");

const auto firstArray{TakeWhile(std::forward<F>(f), c)};
const auto secondArray{Drop(firstArray.Count(), c)};
return Array{firstArray, secondArray};
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Subs(const C& c, const SizeType start, const SizeType end) noexcept {
static_assert(IsCljonicCollection<C>, "Subs's first parameter must be a cljonic collection");

return ((c.Count() == 0) or (start >= c.Count()) or (end <= start))
           ? Array<typename C::value_type, c.MaximumCount()>{}
           : Take((end - start), Drop(start, c));
}

template <typename C>
constexpr auto Subs(const C& c, const SizeType start) noexcept {
static_assert(IsCljonicCollection<C>, "Subs's first parameter must be a cljonic collection");

return Subs(c, start, c.Count());
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto Take(const SizeType count, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Take's second parameter must be a cljonic collection");

using ResultType = typename C::value_type;
auto result{Array<ResultType, c.MaximumCount()>{}};
auto maxIndex{MinArgument(count, c.Count())};
auto cBegin{c.begin()};
auto cEnd{cBegin + maxIndex};
for(auto it{cBegin}; it != cEnd; ++it)
result.MAppend(static_cast<ResultType>(*it));
return result;
}

template <SizeType N, typename C>
constexpr auto Take(const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "Take's parameter must be a cljonic collection");

using ResultType = typename C::value_type;
auto result{Array<ResultType, N>{}};
auto maxIndex{MinArgument(N, c.Count())};
auto cBegin{c.begin()};
auto cEnd{cBegin + maxIndex};
for(auto it{cBegin}; it != cEnd; ++it)
result.MAppend(static_cast<ResultType>(*it));
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto TakeLast(const SizeType count, const C& c) noexcept {
static_assert(IsCljonicCollection<C>, "TakeLast's second parameter must be a cljonic collection");

auto result{Array<typename C::value_type, c.MaximumCount()>{}};
auto startIndex{(c.Count() > count) ? (c.Count() - count) : 0};
auto cBegin{c.begin()};
auto cEnd{c.end()};
for(auto it{cBegin + startIndex}; it != cEnd; ++it)
result.MAppend(*it);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename C>
constexpr auto TakeNth(const SizeType nth, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "TakeNth's second parameter must be a cljonic collection");

using ResultType = Array<typename C::value_type, c.MaximumCount()>;
using ValueType = typename C::value_type;

constexpr auto FillArray = [](ResultType& r, const ValueType& v) noexcept {
for(SizeType i{0}; i < r.MaximumCount(); ++i)
r.MAppend(v);
};
constexpr auto FillArrayNth = [](ResultType& r, const C& vArray, const SizeType nth) noexcept {
auto it{vArray.begin()};
auto vArrayEnd{vArray.end()};
while(it != vArrayEnd) {
r.MAppend(*it);
for(SizeType i{0}; (i < nth) and (it != vArrayEnd); ++i)
++it;
}
};
auto result{ResultType{}};
if((c.Count() > 0) and (0 == nth))
FillArray(result, *c.begin());
else if(c.Count() > 0)
FillArrayNth(result, c, nth);
return result;
}

}

} // namespace cljonic::core

namespace cljonic {

namespace core {
template <typename F, typename C>
constexpr auto TakeWhile(F&& f, const C& c) noexcept {

static_assert(IsCljonicCollection<C>, "TakeWhile's second parameter must be a cljonic collection");

static_assert(IsUnaryPredicate<std::decay_t<F>, typename C::value_type>,
              "TakeWhile's function is not a valid unary predicate for the collection value type");

auto result{Array<typename C::value_type, c.MaximumCount()>{}};
for(const auto& element : c)
if(f(element))
result.MAppend(element);
else
break;
return result;
}

}

} // namespace cljonic::core

#endif // CLJONIC_H_
